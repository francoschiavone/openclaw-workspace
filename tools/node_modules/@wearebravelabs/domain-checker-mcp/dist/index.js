#!/usr/bin/env node
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import dns from "dns/promises";
import whois from "whois-json";
const server = new McpServer({
    name: "domain-checker",
    version: "1.0.0",
});
const POPULAR_TLDS = [
    "com", "net", "org", "io", "co", "app", "dev", "ai",
    "xyz", "me", "info", "biz", "us", "uk", "ca", "au"
];
const IANA_RDAP_BOOTSTRAP = "https://data.iana.org/rdap/dns.json";
let rdapServers = null;
let rdapLoadPromise = null;
async function loadRdapServers() {
    if (rdapServers)
        return rdapServers;
    if (rdapLoadPromise) {
        await rdapLoadPromise;
        return rdapServers;
    }
    rdapLoadPromise = (async () => {
        try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 10000);
            const response = await fetch(IANA_RDAP_BOOTSTRAP, { signal: controller.signal });
            clearTimeout(timeout);
            if (!response.ok) {
                rdapServers = new Map();
                return;
            }
            const data = await response.json();
            rdapServers = new Map();
            for (const [tlds, urls] of data.services) {
                if (urls.length > 0) {
                    const url = urls[0].replace(/\/$/, "");
                    for (const tld of tlds) {
                        rdapServers.set(tld.toLowerCase(), url);
                    }
                }
            }
        }
        catch {
            rdapServers = new Map();
        }
    })();
    await rdapLoadPromise;
    return rdapServers;
}
const DNS_TIMEOUT = 3000;
const RDAP_TIMEOUT = 10000;
const WHOIS_TIMEOUT = 10000;
const BATCH_SIZE = 20;
async function checkDomainDNS(domain) {
    const start = Date.now();
    try {
        await Promise.race([
            dns.resolve(domain),
            new Promise((_, reject) => setTimeout(() => reject(new Error("timeout")), DNS_TIMEOUT)),
        ]);
        return {
            domain,
            available: false,
            method: "dns",
            verified: true,
            responseTime: Date.now() - start,
        };
    }
    catch (error) {
        const responseTime = Date.now() - start;
        if (error.code === "ENOTFOUND" || error.code === "ENODATA") {
            return {
                domain,
                available: true,
                method: "dns",
                verified: false,
                responseTime,
            };
        }
        if (error.message === "timeout") {
            return {
                domain,
                available: false,
                method: "dns",
                verified: false,
                responseTime,
                error: "DNS timeout",
            };
        }
        return {
            domain,
            available: false,
            method: "dns",
            verified: false,
            responseTime,
            error: error.code || error.message,
        };
    }
}
async function checkRDAP(domain) {
    const tld = domain.split(".").pop()?.toLowerCase();
    if (!tld)
        return null;
    const servers = await loadRdapServers();
    const serverUrl = servers.get(tld);
    if (!serverUrl)
        return null;
    const url = `${serverUrl}/domain/${domain}`;
    try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), RDAP_TIMEOUT);
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeout);
        if (response.status === 200) {
            return { available: false, method: "rdap" };
        }
        if (response.status === 404) {
            return { available: true, method: "rdap" };
        }
        return null;
    }
    catch {
        return null;
    }
}
async function checkWhois(domain) {
    try {
        const result = await Promise.race([
            whois(domain),
            new Promise((_, reject) => setTimeout(() => reject(new Error("timeout")), WHOIS_TIMEOUT)),
        ]);
        if (!result || typeof result !== "object") {
            return { available: false, method: "whois", error: "Invalid WHOIS response" };
        }
        const registrationFields = [
            "domainName", "registrar", "creationDate", "createdDate",
            "registrantName", "registrantOrganization", "nameServer",
        ];
        const hasRegistration = registrationFields.some((field) => {
            const value = result[field];
            return value !== undefined && value !== null && value !== "";
        });
        if (hasRegistration) {
            return { available: false, method: "whois" };
        }
        const resultStr = JSON.stringify(result).toLowerCase();
        const availableIndicators = ["no match", "not found", "no entries found", "no data found", "available"];
        const hasAvailableIndicator = availableIndicators.some((indicator) => resultStr.includes(indicator));
        if (hasAvailableIndicator) {
            return { available: true, method: "whois" };
        }
        return { available: false, method: "whois", error: "Uncertain WHOIS result" };
    }
    catch (error) {
        return {
            available: false,
            method: "whois",
            error: error.message === "timeout" ? "WHOIS timeout" : error.message,
        };
    }
}
async function verifyAvailability(domain) {
    const rdapResult = await checkRDAP(domain);
    if (rdapResult) {
        return rdapResult;
    }
    return checkWhois(domain);
}
async function checkDomainsHybrid(domains) {
    const dnsResults = await Promise.all(domains.map((domain) => checkDomainDNS(domain)));
    const needsVerification = dnsResults.filter((r) => r.available && !r.verified);
    const definitelyTaken = dnsResults.filter((r) => !r.available);
    const verifiedResults = [];
    for (let i = 0; i < needsVerification.length; i += BATCH_SIZE) {
        const batch = needsVerification.slice(i, i + BATCH_SIZE);
        const batchResults = await Promise.all(batch.map(async (dnsResult) => {
            const verification = await verifyAvailability(dnsResult.domain);
            return {
                ...dnsResult,
                available: verification.available,
                method: `dns+${verification.method}`,
                verified: true,
                ...(verification.error && { error: verification.error }),
            };
        }));
        verifiedResults.push(...batchResults);
    }
    const resultMap = new Map();
    for (const r of definitelyTaken)
        resultMap.set(r.domain, r);
    for (const r of verifiedResults)
        resultMap.set(r.domain, r);
    return domains.map((d) => resultMap.get(d));
}
function normalizeDomain(input) {
    return input
        .toLowerCase()
        .trim()
        .replace(/^https?:\/\//, "")
        .replace(/^www\./, "")
        .replace(/\/.*$/, "");
}
function generateVariations(baseName, tlds) {
    const name = baseName.replace(/\.[a-z]{2,}$/i, "");
    return tlds.map((tld) => `${name}.${tld}`);
}
const filterSchema = z
    .enum(["available", "taken"])
    .optional()
    .describe("Filter results: 'available' or 'taken'. Omit for all.");
function formatResults(results, filter, totalTime) {
    const available = results.filter((r) => r.available && !r.error);
    const taken = results.filter((r) => !r.available && !r.error);
    const errors = results.filter((r) => r.error);
    const response = {
        summary: {
            total: results.length,
            available: available.length,
            taken: taken.length,
            errors: errors.length,
            totalTime: `${totalTime}ms`,
        },
    };
    if (!filter || filter === "available") {
        response.available = available.map((r) => r.domain);
    }
    if (!filter || filter === "taken") {
        response.taken = taken.map((r) => r.domain);
    }
    if (errors.length > 0) {
        response.errors = errors.map((r) => ({ domain: r.domain, error: r.error }));
    }
    return response;
}
function jsonResponse(data) {
    return {
        content: [{ type: "text", text: JSON.stringify(data) }],
    };
}
function errorResponse(message) {
    return jsonResponse({ error: message });
}
// Tools
server.tool("check_domains", "Check if domains are available for registration. Uses DNS + RDAP/WHOIS for accuracy.", {
    domains: z.array(z.string()).describe("Domain names to check (e.g., ['example.com', 'test.io'])"),
    filter: filterSchema,
}, async ({ domains, filter }) => {
    const normalized = domains.map(normalizeDomain).filter((d) => d.includes("."));
    if (normalized.length === 0) {
        return errorResponse("No valid domains provided. Include TLD (e.g., example.com)");
    }
    const start = Date.now();
    const results = await checkDomainsHybrid(normalized);
    return jsonResponse(formatResults(results, filter, Date.now() - start));
});
server.tool("check_names", "Check base names across popular TLDs (e.g., ['myproject'] checks myproject.com, .io, .net, etc.)", {
    names: z.array(z.string()).describe("Base names to check (e.g., ['myproject', 'coolapp'])"),
    tlds: z.array(z.string()).optional().describe("Optional: specific TLDs to check. Defaults to popular TLDs."),
    filter: filterSchema,
}, async ({ names, tlds, filter }) => {
    const tldsToCheck = tlds && tlds.length > 0 ? tlds : POPULAR_TLDS;
    const domains = names.flatMap((name) => generateVariations(name, tldsToCheck));
    const start = Date.now();
    const results = await checkDomainsHybrid(domains);
    return jsonResponse({ names, ...formatResults(results, filter, Date.now() - start) });
});
server.tool("check_domains_quick", "Quick DNS-only check without RDAP/WHOIS verification. Fast but may have false positives for 'available'.", {
    domains: z.array(z.string()).describe("Domain names to check"),
    filter: filterSchema,
}, async ({ domains, filter }) => {
    const normalized = domains.map(normalizeDomain).filter((d) => d.includes("."));
    if (normalized.length === 0) {
        return errorResponse("No valid domains provided. Include TLD (e.g., example.com)");
    }
    const start = Date.now();
    const results = await Promise.all(normalized.map((d) => checkDomainDNS(d)));
    return jsonResponse({
        ...formatResults(results, filter, Date.now() - start),
        note: "DNS-only check - use check_domains for RDAP/WHOIS verification",
    });
});
// Server
async function main() {
    loadRdapServers();
    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.error("Domain Checker MCP server running on stdio");
}
main().catch((error) => {
    console.error("Fatal error:", error);
    process.exit(1);
});
//# sourceMappingURL=index.js.map