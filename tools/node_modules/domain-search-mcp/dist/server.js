#!/usr/bin/env node
"use strict";
/**
 * Domain Search MCP Server.
 *
 * Model Context Protocol server for domain availability search.
 * Supports Porkbun, Namecheap, RDAP, and WHOIS as data sources.
 *
 * Features:
 * - search_domain: Check availability across multiple TLDs
 * - bulk_search: Check many domains at once
 * - compare_registrars: Compare pricing across registrars
 * - suggest_domains: Generate available name variations
 * - suggest_domains_smart: AI-powered domain suggestions with Qwen 2.5-7B
 * - tld_info: Get TLD information and recommendations
 * - check_socials: Check social handle availability
 * - analyze_project: Extract context from projects for domain suggestions
 * - hunt_domains: Find valuable domains for investment
 * - expiring_domains: Find domains about to expire (federated cache)
 *
 * @see https://github.com/yourusername/domain-search-mcp
 */
Object.defineProperty(exports, "__esModule", { value: true });
const index_js_1 = require("@modelcontextprotocol/sdk/server/index.js");
const stdio_js_1 = require("@modelcontextprotocol/sdk/server/stdio.js");
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const index_js_2 = require("./transports/index.js");
const http_js_1 = require("./transports/http.js");
const config_js_1 = require("./config.js");
const logger_js_1 = require("./utils/logger.js");
const errors_js_1 = require("./utils/errors.js");
const format_js_1 = require("./utils/format.js");
const rdap_js_1 = require("./fallbacks/rdap.js");
const index_js_3 = require("./tools/index.js");
// ═══════════════════════════════════════════════════════════════════════════
// Server Configuration
// ═══════════════════════════════════════════════════════════════════════════
const SERVER_NAME = 'domain-search-mcp';
// NOTE: Keep in sync with package.json version
const SERVER_VERSION = '1.9.8';
/**
 * All available tools.
 */
const TOOLS = [
    index_js_3.searchDomainTool,
    index_js_3.bulkSearchTool,
    index_js_3.compareRegistrarsTool,
    index_js_3.suggestDomainsTool,
    index_js_3.suggestDomainsSmartTool,
    index_js_3.tldInfoTool,
    index_js_3.checkSocialsTool,
    index_js_3.analyzeProjectTool,
    index_js_3.huntDomainsTool,
    index_js_3.expiringDomainsTool,
    index_js_3.aiHealthTool,
];
// ═══════════════════════════════════════════════════════════════════════════
// Server Implementation
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Create and configure the MCP server.
 */
function createServer() {
    const server = new index_js_1.Server({
        name: SERVER_NAME,
        version: SERVER_VERSION,
    }, {
        capabilities: {
            tools: {},
        },
    });
    // Register tool listing handler
    server.setRequestHandler(types_js_1.ListToolsRequestSchema, async () => {
        return { tools: TOOLS };
    });
    // Register tool call handler
    server.setRequestHandler(types_js_1.CallToolRequestSchema, async (request) => {
        const { name, arguments: args } = request.params;
        const requestId = (0, logger_js_1.generateRequestId)();
        try {
            (0, logger_js_1.setRequestId)(requestId);
            logger_js_1.logger.info('Tool call started', { tool: name, request_id: requestId });
            const result = await executeToolCall(name, args || {});
            logger_js_1.logger.info('Tool call completed', {
                tool: name,
                request_id: requestId,
            });
            return {
                content: [
                    {
                        type: 'text',
                        text: (0, format_js_1.formatToolResult)(name, result, config_js_1.config.outputFormat),
                    },
                ],
            };
        }
        catch (error) {
            const wrapped = (0, errors_js_1.wrapError)(error);
            logger_js_1.logger.error('Tool call failed', {
                tool: name,
                request_id: requestId,
                error: wrapped.message,
                code: wrapped.code,
            });
            // Return error as content (MCP pattern)
            return {
                content: [
                    {
                        type: 'text',
                        text: (0, format_js_1.formatToolError)({
                            code: wrapped.code,
                            userMessage: wrapped.userMessage,
                            retryable: wrapped.retryable,
                            suggestedAction: wrapped.suggestedAction,
                        }, config_js_1.config.outputFormat),
                    },
                ],
                isError: true,
            };
        }
        finally {
            (0, logger_js_1.clearRequestId)();
        }
    });
    return server;
}
/**
 * Execute a tool call by name.
 *
 * SECURITY: Each executor internally validates input with Zod schemas.
 * We pass raw args directly to let Zod handle type coercion and validation,
 * which prevents type confusion attacks where e.g. a string is passed
 * instead of an array.
 */
async function executeToolCall(name, args) {
    // All executors internally use Zod schemas for validation.
    // Passing raw args ensures proper type coercion and error messages.
    switch (name) {
        case 'search_domain':
            return (0, index_js_3.executeSearchDomain)(args);
        case 'bulk_search':
            return (0, index_js_3.executeBulkSearch)(args);
        case 'compare_registrars':
            return (0, index_js_3.executeCompareRegistrars)(args);
        case 'suggest_domains':
            return (0, index_js_3.executeSuggestDomains)(args);
        case 'suggest_domains_smart':
            return (0, index_js_3.executeSuggestDomainsSmart)(args);
        case 'tld_info':
            return (0, index_js_3.executeTldInfo)(args);
        case 'check_socials':
            return (0, index_js_3.executeCheckSocials)(args);
        case 'analyze_project':
            return (0, index_js_3.executeAnalyzeProject)(args);
        case 'hunt_domains':
            return (0, index_js_3.executeHuntDomains)(args);
        case 'expiring_domains':
            return (0, index_js_3.executeExpiringDomains)(args);
        case 'ai_health':
            return (0, index_js_3.executeAiHealth)(args);
        default:
            throw new errors_js_1.DomainSearchError('UNKNOWN_TOOL', `Unknown tool: ${name}`, `The tool "${name}" is not available.`, {
                retryable: false,
                suggestedAction: `Available tools: ${TOOLS.map((t) => t.name).join(', ')}`,
            });
    }
}
// ═══════════════════════════════════════════════════════════════════════════
// Startup
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Main entry point.
 */
async function main() {
    // Get transport configuration from CLI args and env vars
    const transportConfig = (0, index_js_2.getTransportConfig)();
    // Log startup info
    logger_js_1.logger.info('Domain Search MCP starting', {
        version: SERVER_VERSION,
        node_version: process.version,
        transport: transportConfig.type,
        sources: (0, config_js_1.getAvailableSources)(),
        has_registrar_api: (0, config_js_1.hasRegistrarApi)(),
        dry_run: config_js_1.config.dryRun,
    });
    // Warn if no API keys configured
    if (!(0, config_js_1.hasRegistrarApi)()) {
        logger_js_1.logger.warn('No registrar API keys configured. Falling back to RDAP/WHOIS only.');
        logger_js_1.logger.warn('For pricing info, set PRICING_API_BASE_URL (recommended) or add BYOK registrar keys.');
    }
    // Create MCP server
    const server = createServer();
    // Pre-warm RDAP bootstrap cache in background (eliminates 5s cold-start latency)
    (0, rdap_js_1.prewarmRdapBootstrap)().catch((err) => {
        logger_js_1.logger.debug('RDAP pre-warm failed (non-fatal)', {
            error: err instanceof Error ? err.message : String(err),
        });
    });
    // Variable to hold HTTP transport for cleanup
    let httpTransport = null;
    // Connect based on transport type
    if (transportConfig.type === 'http') {
        // HTTP/SSE transport for web clients (ChatGPT, LM Studio, etc.)
        httpTransport = (0, http_js_1.createHttpTransport)(server, transportConfig);
        await httpTransport.start();
        logger_js_1.logger.info('Domain Search MCP ready', {
            tools: TOOLS.length,
            transport: (0, index_js_2.formatTransportInfo)(transportConfig),
            port: transportConfig.port,
            host: transportConfig.host,
        });
        // Log helpful URLs
        const baseUrl = `http://${transportConfig.host === '0.0.0.0' ? 'localhost' : transportConfig.host}:${transportConfig.port}`;
        logger_js_1.logger.info(`MCP endpoint: ${baseUrl}/mcp`);
        logger_js_1.logger.info(`Health check: ${baseUrl}/health`);
    }
    else {
        // Stdio transport for Claude Desktop, Cursor, VS Code (default)
        const transport = new stdio_js_1.StdioServerTransport();
        await server.connect(transport);
        logger_js_1.logger.info('Domain Search MCP ready', {
            tools: TOOLS.length,
            transport: 'stdio',
        });
    }
    // Handle graceful shutdown
    const shutdown = async (signal) => {
        logger_js_1.logger.info(`Received ${signal}, shutting down...`);
        if (httpTransport) {
            await httpTransport.stop();
        }
        await server.close();
        process.exit(0);
    };
    process.on('SIGINT', () => shutdown('SIGINT'));
    process.on('SIGTERM', () => shutdown('SIGTERM'));
}
// Run the server
main().catch((error) => {
    logger_js_1.logger.error('Failed to start server', {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
    });
    process.exit(1);
});
//# sourceMappingURL=server.js.map