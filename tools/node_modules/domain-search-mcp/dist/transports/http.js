"use strict";
/**
 * HTTP/SSE Transport for MCP Server
 *
 * Implements the MCP Streamable HTTP transport specification.
 * Enables web-based clients (ChatGPT, LM Studio, web apps) to connect.
 *
 * Routes:
 * - POST /mcp - JSON-RPC message endpoint
 * - GET /mcp - SSE stream for server-initiated messages
 * - GET /health - Health check endpoint
 * - GET / - Server info
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHttpTransport = createHttpTransport;
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const express_rate_limit_1 = __importDefault(require("express-rate-limit"));
const crypto_1 = require("crypto");
const streamableHttp_js_1 = require("@modelcontextprotocol/sdk/server/streamableHttp.js");
const generator_js_1 = require("../openapi/generator.js");
const routes_js_1 = require("../api/routes.js");
const metrics_js_1 = require("../utils/metrics.js");
const circuit_breaker_js_1 = require("../utils/circuit-breaker.js");
const adaptive_concurrency_js_1 = require("../utils/adaptive-concurrency.js");
const redis_cache_js_1 = require("../utils/redis-cache.js");
/**
 * Creates an Express server with MCP HTTP transport.
 *
 * The server uses StreamableHTTPServerTransport which implements
 * the MCP Streamable HTTP specification (2025-06-18).
 *
 * @param mcpServer - The MCP Server instance to connect
 * @param config - Transport configuration (port, host, CORS)
 * @returns Object with Express app, HTTP server, and start/stop functions
 */
function createHttpTransport(mcpServer, config) {
    const app = (0, express_1.default)();
    // Middleware
    app.use(express_1.default.json({ limit: '4mb' }));
    // CORS configuration
    const corsOptions = {
        origin: config.corsOrigins || ['*'],
        methods: ['GET', 'POST', 'OPTIONS'],
        allowedHeaders: [
            'Content-Type',
            'Authorization',
            'Mcp-Session-Id',
            'Last-Event-ID'
        ],
        exposedHeaders: ['Mcp-Session-Id'],
        credentials: true
    };
    app.use((0, cors_1.default)(corsOptions));
    // Rate limiting - 100 requests per minute per IP
    const limiter = (0, express_rate_limit_1.default)({
        windowMs: 60 * 1000, // 1 minute
        max: 100, // 100 requests per window
        standardHeaders: true,
        legacyHeaders: false,
        message: {
            error: 'Too many requests',
            message: 'Rate limit exceeded. Please try again later.',
            retryAfter: 60
        },
        skip: (req) => {
            // Skip rate limiting for health checks
            return req.path === '/health';
        }
    });
    app.use(limiter);
    // Store active transports by session ID
    const transports = new Map();
    // Mount REST API routes for ChatGPT Actions and other REST clients
    app.use('/api', (0, routes_js_1.createApiRouter)());
    /**
     * MCP endpoint - handles both POST (messages) and GET (SSE stream)
     */
    app.all('/mcp', async (req, res) => {
        // Check for existing session
        const sessionId = req.headers['mcp-session-id'];
        if (req.method === 'GET') {
            // SSE stream request
            if (!sessionId || !transports.has(sessionId)) {
                res.status(400).json({
                    error: 'No active session',
                    message: 'Establish a session first with POST /mcp'
                });
                return;
            }
            const transport = transports.get(sessionId);
            // Cast to IncomingMessage/ServerResponse for MCP SDK compatibility
            await transport.handleRequest(req, res);
            return;
        }
        if (req.method === 'POST') {
            // Check if this is an initialization request (no session ID needed)
            const body = req.body;
            const isInitRequest = body?.method === 'initialize' || !sessionId;
            let transport;
            if (isInitRequest && !sessionId) {
                // Create new transport for new session
                transport = new streamableHttp_js_1.StreamableHTTPServerTransport({
                    sessionIdGenerator: () => (0, crypto_1.randomUUID)()
                });
                // Set up event handlers
                transport.onclose = () => {
                    const sid = transport.sessionId;
                    if (sid) {
                        transports.delete(sid);
                    }
                };
                transport.onerror = (error) => {
                    console.error('[HTTP Transport] Error:', error);
                };
                // Connect MCP server to this transport
                await mcpServer.connect(transport);
                // Store transport by session ID
                if (transport.sessionId) {
                    transports.set(transport.sessionId, transport);
                }
            }
            else if (sessionId && transports.has(sessionId)) {
                // Use existing transport
                transport = transports.get(sessionId);
            }
            else {
                // Invalid session
                res.status(404).json({
                    error: 'Session not found',
                    message: 'Invalid or expired session ID'
                });
                return;
            }
            // Handle the request - cast for MCP SDK compatibility
            await transport.handleRequest(req, res, req.body);
            return;
        }
        // Method not allowed
        res.status(405).json({
            error: 'Method not allowed',
            allowed: ['GET', 'POST']
        });
    });
    /**
     * Health check endpoint
     */
    app.get('/health', (_req, res) => {
        res.json({
            status: 'ok',
            transport: 'http',
            activeSessions: transports.size,
            uptime: process.uptime()
        });
    });
    /**
     * Metrics endpoint for observability.
     *
     * Returns latency histograms (with percentiles), counters, and cache hit rates.
     * Useful for monitoring performance and debugging.
     */
    app.get('/metrics', (_req, res) => {
        try {
            const metrics = (0, metrics_js_1.getMetricsSummary)();
            const hybridCache = (0, redis_cache_js_1.getDefaultHybridCache)();
            res.json({
                ...metrics,
                circuit_breakers: (0, circuit_breaker_js_1.getAllCircuitStates)(),
                adaptive_limiters: (0, adaptive_concurrency_js_1.getAllAdaptiveStates)(),
                redis_cache: hybridCache.getStats(),
                active_sessions: transports.size,
                memory: {
                    heap_used_mb: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
                    heap_total_mb: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),
                    rss_mb: Math.round(process.memoryUsage().rss / 1024 / 1024),
                },
            });
        }
        catch (error) {
            console.error('[Metrics] Failed to collect:', error);
            res.status(500).json({
                error: 'Failed to collect metrics',
                message: error instanceof Error ? error.message : 'Unknown error',
            });
        }
    });
    /**
     * OpenAPI specification endpoint
     * Used by ChatGPT Actions and other REST API clients
     */
    app.get('/openapi.json', (req, res) => {
        // Determine base URL from request or config
        const protocol = req.headers['x-forwarded-proto'] || req.protocol || 'http';
        const host = req.headers['x-forwarded-host'] || req.headers.host || 'localhost:3000';
        const baseUrl = `${protocol}://${host}`;
        try {
            const spec = (0, generator_js_1.generateOpenAPISpec)(baseUrl);
            res.json(spec);
        }
        catch (error) {
            console.error('[OpenAPI] Generation failed:', error);
            res.status(500).json({
                error: 'Failed to generate OpenAPI spec',
                message: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    });
    /**
     * Server info endpoint
     */
    app.get('/', (_req, res) => {
        res.json({
            name: 'domain-search-mcp',
            transport: 'Streamable HTTP',
            endpoints: {
                mcp: '/mcp',
                openapi: '/openapi.json',
                health: '/health',
                metrics: '/metrics'
            },
            docs: 'https://github.com/dorukardahan/domain-search-mcp'
        });
    });
    /**
     * 404 handler
     */
    app.use((_req, res) => {
        res.status(404).json({
            error: 'Not found',
            message: 'Use /mcp for MCP protocol, /health for health check'
        });
    });
    /**
     * Error handler
     */
    app.use((err, _req, res, _next) => {
        console.error('[HTTP Transport] Unhandled error:', err);
        res.status(500).json({
            error: 'Internal server error',
            message: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    });
    // Create HTTP server
    let server = null;
    return {
        app,
        /**
         * Start the HTTP server
         */
        start() {
            const port = config.port ?? 3000;
            const host = config.host ?? '0.0.0.0';
            return new Promise((resolve, reject) => {
                try {
                    server = app.listen(port, host, () => {
                        resolve();
                    });
                    server.on('error', (err) => {
                        if (err.code === 'EADDRINUSE') {
                            reject(new Error(`Port ${port} is already in use`));
                        }
                        else {
                            reject(err);
                        }
                    });
                }
                catch (err) {
                    reject(err);
                }
            });
        },
        /**
         * Stop the HTTP server and close all transports
         */
        async stop() {
            // Close all active transports
            for (const transport of transports.values()) {
                await transport.close();
            }
            transports.clear();
            // Close HTTP server
            if (server) {
                return new Promise((resolve, reject) => {
                    server.close((err) => {
                        if (err)
                            reject(err);
                        else
                            resolve();
                    });
                });
            }
        },
        /**
         * Get count of active sessions
         */
        getActiveSessionCount() {
            return transports.size;
        }
    };
}
//# sourceMappingURL=http.js.map