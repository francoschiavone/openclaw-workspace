"use strict";
/**
 * Namecheap Registrar Adapter.
 *
 * Namecheap uses an XML-based API.
 * API Docs: https://www.namecheap.com/support/api/intro/
 *
 * Note: Namecheap requires IP whitelisting for API access.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.namecheapAdapter = exports.NamecheapAdapter = void 0;
const axios_1 = __importDefault(require("axios"));
const zod_1 = require("zod");
const base_js_1 = require("./base.js");
const config_js_1 = require("../config.js");
const logger_js_1 = require("../utils/logger.js");
const errors_js_1 = require("../utils/errors.js");
const NAMECHEAP_API_BASE = 'https://api.namecheap.com/xml.response';
const NAMECHEAP_SANDBOX_BASE = 'https://api.sandbox.namecheap.com/xml.response';
// ═══════════════════════════════════════════════════════════════════════════
// Zod Schemas for Parsed XML Validation
// SECURITY: Validate parsed XML data to ensure expected structure
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Schema for parsed domain check result.
 */
const NamecheapCheckResultSchema = zod_1.z.object({
    available: zod_1.z.boolean(),
    premium: zod_1.z.boolean(),
    price: zod_1.z.number().optional(),
    renewalPrice: zod_1.z.number().optional(),
});
// ═══════════════════════════════════════════════════════════════════════════
// XML Parsing Utilities (Internal - hardcoded tags only)
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Allowed XML tags for parsing.
 * SECURITY: Only these hardcoded tags can be parsed to prevent injection.
 */
const ALLOWED_XML_TAGS = new Set([
    'Error',
    'Errors',
    'DomainCheckResult',
]);
const ALLOWED_XML_ATTRS = new Set([
    'Count',
    'Available',
    'IsPremiumName',
    'PremiumRegistrationPrice',
    'PremiumRenewalPrice',
]);
/**
 * Parse XML response to extract domain info.
 * Simple regex-based parsing since we don't want xml2js dependency.
 *
 * SECURITY: Only parses allowed tags defined in ALLOWED_XML_TAGS.
 */
function parseXmlValue(xml, tag) {
    if (!ALLOWED_XML_TAGS.has(tag)) {
        logger_js_1.logger.warn('Attempted to parse disallowed XML tag', { tag });
        return undefined;
    }
    // Escape special regex chars in tag name for safety
    const escapedTag = tag.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    // Reason: tag parameter is validated against ALLOWED_XML_TAGS whitelist above, not user input
    const regex = new RegExp(`<${escapedTag}>([^<]*)</${escapedTag}>`, 'i'); // nosemgrep: detect-non-literal-regexp
    const match = xml.match(regex);
    return match?.[1];
}
function parseXmlAttribute(xml, tag, attr) {
    if (!ALLOWED_XML_TAGS.has(tag)) {
        logger_js_1.logger.warn('Attempted to parse disallowed XML tag', { tag });
        return undefined;
    }
    if (!ALLOWED_XML_ATTRS.has(attr)) {
        logger_js_1.logger.warn('Attempted to parse disallowed XML attribute', { attr });
        return undefined;
    }
    // Escape special regex chars for safety
    const escapedTag = tag.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const escapedAttr = attr.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    // Reason: tag/attr parameters are validated against ALLOWED_XML_TAGS/ATTRS whitelists above, not user input
    const regex = new RegExp(`<${escapedTag}[^>]*${escapedAttr}="([^"]*)"`, 'i'); // nosemgrep: detect-non-literal-regexp
    const match = xml.match(regex);
    return match?.[1];
}
function parseXmlBool(value) {
    return value?.toLowerCase() === 'true';
}
/**
 * Namecheap adapter implementation.
 */
class NamecheapAdapter extends base_js_1.RegistrarAdapter {
    name = 'Namecheap';
    id = 'namecheap';
    client;
    apiKey;
    apiUser;
    useSandbox;
    constructor() {
        // Namecheap has stricter rate limits, ~20/min is safe
        super(20);
        this.apiKey = config_js_1.config.namecheap.apiKey;
        this.apiUser = config_js_1.config.namecheap.apiUser;
        this.useSandbox = false; // Set to true for testing
        const baseURL = this.useSandbox ? NAMECHEAP_SANDBOX_BASE : NAMECHEAP_API_BASE;
        this.client = axios_1.default.create({
            baseURL,
            timeout: this.timeoutMs,
        });
    }
    /**
     * Check if Namecheap API is enabled.
     */
    isEnabled() {
        return config_js_1.config.namecheap.enabled;
    }
    /**
     * Search for domain availability.
     */
    async search(domain, tld) {
        if (!this.isEnabled()) {
            throw new errors_js_1.AuthenticationError('namecheap', 'API credentials not configured');
        }
        const fullDomain = `${domain}.${tld}`;
        logger_js_1.logger.debug('Namecheap search', { domain: fullDomain });
        try {
            const result = await this.retryWithBackoff(async () => {
                const response = await this.client.get('', {
                    params: {
                        ApiUser: this.apiUser,
                        ApiKey: this.apiKey,
                        UserName: this.apiUser,
                        ClientIp: this.getClientIp(),
                        Command: 'namecheap.domains.check',
                        DomainList: fullDomain,
                    },
                });
                return this.parseCheckResponse(response.data, fullDomain);
            }, `check ${fullDomain}`);
            return this.createResult(domain, tld, {
                available: result.available,
                premium: result.premium,
                price_first_year: result.price,
                price_renewal: result.renewalPrice,
                privacy_included: false, // Namecheap charges for privacy
                source: 'namecheap_api',
                premium_reason: result.premium ? 'Premium domain' : undefined,
            });
        }
        catch (error) {
            this.handleApiError(error, fullDomain);
            throw error;
        }
    }
    /**
     * Parse the check response XML.
     * SECURITY: Validates parsed result with Zod schema.
     */
    parseCheckResponse(xml, domain) {
        // Check for API errors
        const errorCount = parseXmlAttribute(xml, 'Errors', 'Count');
        if (errorCount && parseInt(errorCount, 10) > 0) {
            const errorMsg = parseXmlValue(xml, 'Error') || 'Unknown API error';
            if (errorMsg.includes('IP not whitelisted')) {
                throw new errors_js_1.AuthenticationError('namecheap', 'IP not whitelisted. Add your IP in Namecheap dashboard.');
            }
            throw new errors_js_1.RegistrarApiError(this.name, errorMsg);
        }
        // Parse domain result
        const available = parseXmlAttribute(xml, 'DomainCheckResult', 'Available');
        const isPremium = parseXmlAttribute(xml, 'DomainCheckResult', 'IsPremiumName');
        const premiumPrice = parseXmlAttribute(xml, 'DomainCheckResult', 'PremiumRegistrationPrice');
        const premiumRenewal = parseXmlAttribute(xml, 'DomainCheckResult', 'PremiumRenewalPrice');
        const rawResult = {
            available: parseXmlBool(available),
            premium: parseXmlBool(isPremium),
            price: premiumPrice ? parseFloat(premiumPrice) : undefined,
            renewalPrice: premiumRenewal ? parseFloat(premiumRenewal) : undefined,
        };
        // Validate parsed result with Zod
        const parseResult = NamecheapCheckResultSchema.safeParse(rawResult);
        if (!parseResult.success) {
            logger_js_1.logger.warn('Namecheap API response validation failed', {
                domain,
                errors: parseResult.error.errors,
            });
            throw new errors_js_1.RegistrarApiError(this.name, 'Invalid API response format');
        }
        return parseResult.data;
    }
    /**
     * Get TLD information.
     */
    async getTldInfo(tld) {
        // Namecheap doesn't have a great TLD info endpoint
        // Return basic info based on known data
        return {
            tld,
            description: `${tld.toUpperCase()} domain`,
            typical_use: this.getTldUseCase(tld),
            price_range: {
                min: 8.88,
                max: 15.98,
                currency: 'USD',
            },
            renewal_price_typical: 12.98,
            restrictions: [],
            popularity: this.getTldPopularity(tld),
            category: this.getTldCategory(tld),
        };
    }
    /**
     * Get client IP for API requests.
     * Namecheap requires this for all API calls.
     *
     * SECURITY: We no longer call external services (ipify.org) to get IP.
     * The IP must be configured via NAMECHEAP_CLIENT_IP environment variable.
     * This prevents unintended IP disclosure to third parties.
     */
    getClientIp() {
        const clientIp = config_js_1.config.namecheap.clientIp;
        if (!clientIp) {
            throw new errors_js_1.AuthenticationError('namecheap', 'NAMECHEAP_CLIENT_IP not configured. Add your whitelisted IP to .env file.');
        }
        // Basic IP format validation (IPv4 or IPv6)
        const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;
        const ipv6Pattern = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
        if (!ipv4Pattern.test(clientIp) && !ipv6Pattern.test(clientIp)) {
            throw new errors_js_1.AuthenticationError('namecheap', `Invalid NAMECHEAP_CLIENT_IP format: "${clientIp}". Must be a valid IPv4 or IPv6 address.`);
        }
        return clientIp;
    }
    /**
     * Handle API errors with user-friendly messages.
     */
    handleApiError(error, domain) {
        if (axios_1.default.isAxiosError(error)) {
            const axiosError = error;
            if (axiosError.response) {
                const status = axiosError.response.status;
                if (status === 401 || status === 403) {
                    throw new errors_js_1.AuthenticationError('namecheap', 'Invalid API credentials');
                }
                if (status === 429) {
                    throw new errors_js_1.RateLimitError('namecheap');
                }
                throw new errors_js_1.RegistrarApiError(this.name, `HTTP ${status}: ${axiosError.message}`, status, error);
            }
            if (axiosError.code === 'ECONNABORTED') {
                throw new errors_js_1.RegistrarApiError(this.name, `Request timed out for ${domain}`, undefined, error);
            }
        }
        throw new errors_js_1.RegistrarApiError(this.name, error instanceof Error ? error.message : 'Unknown error', undefined, error instanceof Error ? error : undefined);
    }
    /**
     * Get typical use case for a TLD.
     */
    getTldUseCase(tld) {
        const useCases = {
            com: 'General commercial websites',
            io: 'Tech startups and SaaS products',
            dev: 'Developer tools and portfolios',
            app: 'Mobile and web applications',
            co: 'Companies and startups',
            net: 'Network services and utilities',
            org: 'Non-profit organizations',
        };
        return useCases[tld] || 'General purpose';
    }
    /**
     * Get TLD popularity rating.
     */
    getTldPopularity(tld) {
        const highPopularity = ['com', 'net', 'org', 'io', 'co'];
        const mediumPopularity = ['dev', 'app', 'ai', 'me'];
        if (highPopularity.includes(tld))
            return 'high';
        if (mediumPopularity.includes(tld))
            return 'medium';
        return 'low';
    }
    /**
     * Get TLD category.
     */
    getTldCategory(tld) {
        const countryTlds = ['uk', 'de', 'fr', 'jp', 'cn', 'au', 'ca', 'us'];
        const sponsoredTlds = ['edu', 'gov', 'mil'];
        const newTlds = ['io', 'dev', 'app', 'ai', 'xyz', 'tech', 'cloud'];
        if (countryTlds.includes(tld))
            return 'country';
        if (sponsoredTlds.includes(tld))
            return 'sponsored';
        if (newTlds.includes(tld))
            return 'new';
        return 'generic';
    }
}
exports.NamecheapAdapter = NamecheapAdapter;
/**
 * Singleton instance.
 */
exports.namecheapAdapter = new NamecheapAdapter();
//# sourceMappingURL=namecheap.js.map