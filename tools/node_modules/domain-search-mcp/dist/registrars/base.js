"use strict";
/**
 * Base Registrar Adapter.
 *
 * Abstract class that all registrar adapters extend.
 * Provides common functionality:
 * - Rate limiting (token bucket)
 * - Retry with exponential backoff
 * - Error handling and logging
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistrarAdapter = exports.RateLimiter = void 0;
const logger_js_1 = require("../utils/logger.js");
const errors_js_1 = require("../utils/errors.js");
const config_js_1 = require("../config.js");
/**
 * Token bucket rate limiter.
 */
class RateLimiter {
    tokens;
    maxTokens;
    refillRate; // tokens per second
    lastRefill;
    constructor(maxPerMinute = 60) {
        this.maxTokens = maxPerMinute;
        this.tokens = maxPerMinute;
        this.refillRate = maxPerMinute / 60; // Convert to per-second
        this.lastRefill = Date.now();
    }
    /**
     * Try to consume a token. Returns true if successful.
     */
    tryConsume() {
        this.refill();
        if (this.tokens >= 1) {
            this.tokens -= 1;
            return true;
        }
        return false;
    }
    /**
     * Wait until a token is available.
     */
    async waitForToken() {
        while (!this.tryConsume()) {
            // Calculate wait time for next token
            const waitMs = Math.ceil(1000 / this.refillRate);
            await sleep(waitMs);
        }
    }
    /**
     * Refill tokens based on elapsed time.
     */
    refill() {
        const now = Date.now();
        const elapsed = (now - this.lastRefill) / 1000;
        const refillAmount = elapsed * this.refillRate;
        this.tokens = Math.min(this.maxTokens, this.tokens + refillAmount);
        this.lastRefill = now;
    }
    /**
     * Get seconds until next token is available.
     */
    getWaitSeconds() {
        if (this.tokens >= 1)
            return 0;
        const neededTokens = 1 - this.tokens;
        return Math.ceil(neededTokens / this.refillRate);
    }
}
exports.RateLimiter = RateLimiter;
/**
 * Sleep helper.
 */
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Abstract base class for registrar adapters.
 */
class RegistrarAdapter {
    /** Rate limiter for this registrar */
    rateLimiter;
    /** Max retry attempts */
    maxRetries = 3;
    /** Base delay for exponential backoff (ms) */
    baseDelayMs = 2000;
    /** Request timeout (ms) */
    timeoutMs = 10000;
    constructor(requestsPerMinute = 60) {
        this.rateLimiter = new RateLimiter(requestsPerMinute);
    }
    /**
     * Execute a function with rate limiting.
     */
    async rateLimitedCall(fn) {
        // Check if we should even try (dry run mode)
        if (config_js_1.config.dryRun) {
            throw new errors_js_1.RegistrarApiError(this.name, 'Dry run mode - no API calls made');
        }
        // Wait for rate limit
        const waitSeconds = this.rateLimiter.getWaitSeconds();
        if (waitSeconds > 0) {
            logger_js_1.logger.debug(`Rate limiting: waiting ${waitSeconds}s for ${this.name}`);
        }
        await this.rateLimiter.waitForToken();
        return fn();
    }
    /**
     * Execute with retry and exponential backoff.
     */
    async retryWithBackoff(fn, operation) {
        let lastError;
        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
            try {
                return await this.rateLimitedCall(fn);
            }
            catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                // Check if we should retry
                const wrapped = (0, errors_js_1.wrapError)(error);
                if (!wrapped.retryable) {
                    throw wrapped;
                }
                // Check if it's a rate limit error with retry-after
                if (error instanceof errors_js_1.RateLimitError && error.retryAfter) {
                    const waitMs = error.retryAfter - Date.now();
                    if (waitMs > 0 && waitMs < 60000) {
                        logger_js_1.logger.info(`Rate limited, waiting ${waitMs}ms`, {
                            registrar: this.name,
                            attempt,
                        });
                        await sleep(waitMs);
                        continue;
                    }
                }
                // Exponential backoff
                if (attempt < this.maxRetries) {
                    const delay = this.baseDelayMs * Math.pow(2, attempt - 1);
                    logger_js_1.logger.warn(`Retry ${attempt}/${this.maxRetries} for ${operation}`, {
                        registrar: this.name,
                        delay_ms: delay,
                        error: lastError.message,
                    });
                    await sleep(delay);
                }
            }
        }
        // All retries failed
        throw lastError || new Error(`Failed after ${this.maxRetries} retries`);
    }
    /**
     * Create a timeout wrapper for a promise.
     */
    withTimeout(promise, operation, timeoutMs = this.timeoutMs) {
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                reject(new errors_js_1.TimeoutError(operation, timeoutMs));
            }, timeoutMs);
            promise
                .then((result) => {
                clearTimeout(timer);
                resolve(result);
            })
                .catch((error) => {
                clearTimeout(timer);
                reject(error);
            });
        });
    }
    /**
     * Log an error with context.
     */
    logError(error, context) {
        logger_js_1.logger.logError(`${this.name} error`, error, {
            registrar: this.id,
            ...context,
        });
    }
    /**
     * Create a standardized DomainResult.
     */
    createResult(domain, tld, data) {
        return {
            domain: `${domain}.${tld}`,
            available: data.available ?? false,
            premium: data.premium ?? false,
            price_first_year: data.price_first_year ?? null,
            price_renewal: data.price_renewal ?? null,
            currency: data.currency ?? 'USD',
            privacy_included: data.privacy_included ?? false,
            transfer_price: data.transfer_price ?? null,
            registrar: this.id,
            source: data.source ?? `${this.id}_api`,
            checked_at: new Date().toISOString(),
            premium_reason: data.premium_reason,
            tld_restrictions: data.tld_restrictions,
            score: data.score,
        };
    }
}
exports.RegistrarAdapter = RegistrarAdapter;
//# sourceMappingURL=base.js.map