"use strict";
/**
 * Porkbun Registrar Adapter.
 *
 * Porkbun offers competitive pricing and a JSON API.
 * API Docs: https://porkbun.com/api/json/v3/documentation
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.porkbunAdapter = exports.PorkbunAdapter = void 0;
const axios_1 = __importDefault(require("axios"));
const zod_1 = require("zod");
const base_js_1 = require("./base.js");
const config_js_1 = require("../config.js");
const logger_js_1 = require("../utils/logger.js");
const errors_js_1 = require("../utils/errors.js");
const PORKBUN_API_BASE = 'https://api.porkbun.com/api/json/v3';
// ═══════════════════════════════════════════════════════════════════════════
// Zod Schemas for API Response Validation
// SECURITY: Validate all external API responses to prevent unexpected data
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Base response schema - all Porkbun responses have this structure.
 */
const PorkbunBaseResponseSchema = zod_1.z.object({
    status: zod_1.z.enum(['SUCCESS', 'ERROR']),
    message: zod_1.z.string().optional(),
});
/**
 * Domain availability check response schema.
 */
const PorkbunCheckResponseSchema = PorkbunBaseResponseSchema.extend({
    avail: zod_1.z.number().optional(), // 1 = available, 0 = taken
    premium: zod_1.z.number().optional(), // 1 = premium
    yourPrice: zod_1.z.string().optional(),
    retailPrice: zod_1.z.string().optional(),
});
/**
 * Pricing response schema for a single TLD.
 */
const PorkbunTldPricingSchema = zod_1.z.object({
    registration: zod_1.z.string(),
    renewal: zod_1.z.string(),
    transfer: zod_1.z.string(),
    coupons: zod_1.z.object({
        registration: zod_1.z.object({
            code: zod_1.z.string(),
            max_per_user: zod_1.z.number(),
            first_year_only: zod_1.z.string(),
            type: zod_1.z.string(),
            amount: zod_1.z.number(),
        }).optional(),
    }).optional(),
});
/**
 * Full pricing response schema.
 */
const PorkbunPricingResponseSchema = PorkbunBaseResponseSchema.extend({
    pricing: zod_1.z.record(zod_1.z.string(), PorkbunTldPricingSchema).optional(),
});
/**
 * Porkbun adapter implementation.
 */
class PorkbunAdapter extends base_js_1.RegistrarAdapter {
    name = 'Porkbun';
    id = 'porkbun';
    client;
    apiKey;
    apiSecret;
    pricingCache = {};
    constructor() {
        // Porkbun has generous rate limits, ~60/min is safe
        super(60);
        this.apiKey = config_js_1.config.porkbun.apiKey;
        this.apiSecret = config_js_1.config.porkbun.apiSecret;
        this.client = axios_1.default.create({
            baseURL: PORKBUN_API_BASE,
            timeout: this.timeoutMs,
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    /**
     * Check if Porkbun API is enabled.
     */
    isEnabled() {
        return config_js_1.config.porkbun.enabled;
    }
    /**
     * Search for domain availability.
     */
    async search(domain, tld) {
        if (!this.isEnabled()) {
            throw new errors_js_1.AuthenticationError('porkbun', 'API credentials not configured');
        }
        const fullDomain = `${domain}.${tld}`;
        logger_js_1.logger.debug('Porkbun search', { domain: fullDomain });
        try {
            // First, try to get pricing (this is cached)
            const pricing = await this.getPricing(tld);
            // Then check availability
            const availability = await this.checkAvailability(domain, tld);
            return this.createResult(domain, tld, {
                available: availability.available,
                premium: availability.premium,
                price_first_year: availability.price ?? pricing?.registration ?? null,
                price_renewal: pricing?.renewal ?? null,
                transfer_price: pricing?.transfer ?? null,
                privacy_included: true, // Porkbun includes WHOIS privacy
                source: 'porkbun_api',
                premium_reason: availability.premium ? 'Premium domain' : undefined,
            });
        }
        catch (error) {
            this.handleApiError(error, fullDomain);
            throw error; // Re-throw if not handled
        }
    }
    /**
     * Check domain availability.
     * SECURITY: Validates API response with Zod schema.
     */
    async checkAvailability(domain, tld) {
        const result = await this.retryWithBackoff(async () => {
            const response = await this.client.post('/domain/check', {
                apikey: this.apiKey,
                secretapikey: this.apiSecret,
                domain: `${domain}.${tld}`,
            });
            // Validate response with Zod schema
            const parseResult = PorkbunCheckResponseSchema.safeParse(response.data);
            if (!parseResult.success) {
                logger_js_1.logger.warn('Porkbun API response validation failed', {
                    domain: `${domain}.${tld}`,
                    errors: parseResult.error.errors,
                });
                throw new errors_js_1.RegistrarApiError(this.name, 'Invalid API response format');
            }
            const validated = parseResult.data;
            if (validated.status !== 'SUCCESS') {
                throw new errors_js_1.RegistrarApiError(this.name, validated.message || 'Unknown error');
            }
            return validated;
        }, `check ${domain}.${tld}`);
        return {
            available: result.avail === 1,
            premium: result.premium === 1,
            price: result.yourPrice ? parseFloat(result.yourPrice) : undefined,
        };
    }
    /**
     * Get pricing for a TLD.
     * SECURITY: Validates API response with Zod schema.
     */
    async getPricing(tld) {
        // Check cache first
        if (this.pricingCache[tld]) {
            return this.pricingCache[tld];
        }
        try {
            const result = await this.retryWithBackoff(async () => {
                const response = await this.client.post('/pricing/get', {
                    apikey: this.apiKey,
                    secretapikey: this.apiSecret,
                });
                // Validate response with Zod schema
                const parseResult = PorkbunPricingResponseSchema.safeParse(response.data);
                if (!parseResult.success) {
                    logger_js_1.logger.warn('Porkbun pricing API response validation failed', {
                        errors: parseResult.error.errors,
                    });
                    throw new errors_js_1.RegistrarApiError(this.name, 'Invalid pricing API response format');
                }
                const validated = parseResult.data;
                if (validated.status !== 'SUCCESS') {
                    throw new errors_js_1.RegistrarApiError(this.name, validated.message || 'Failed to get pricing');
                }
                return validated.pricing;
            }, 'get pricing');
            if (result) {
                // Cache all TLD pricing
                for (const [tldKey, prices] of Object.entries(result)) {
                    this.pricingCache[tldKey] = {
                        registration: parseFloat(prices.registration),
                        renewal: parseFloat(prices.renewal),
                        transfer: parseFloat(prices.transfer),
                    };
                }
            }
            return this.pricingCache[tld] || null;
        }
        catch (error) {
            logger_js_1.logger.warn('Failed to get Porkbun pricing', {
                tld,
                error: error instanceof Error ? error.message : String(error),
            });
            return null;
        }
    }
    /**
     * Get TLD information.
     */
    async getTldInfo(tld) {
        const pricing = await this.getPricing(tld);
        if (!pricing)
            return null;
        return {
            tld,
            description: `${tld.toUpperCase()} domain`,
            typical_use: this.getTldUseCase(tld),
            price_range: {
                min: pricing.registration,
                max: pricing.registration,
                currency: 'USD',
            },
            renewal_price_typical: pricing.renewal,
            restrictions: [],
            popularity: this.getTldPopularity(tld),
            category: this.getTldCategory(tld),
        };
    }
    /**
     * Handle API errors with user-friendly messages.
     */
    handleApiError(error, domain) {
        if (axios_1.default.isAxiosError(error)) {
            const axiosError = error;
            if (axiosError.response) {
                const status = axiosError.response.status;
                const message = axiosError.response.data?.message || axiosError.message;
                if (status === 401 || status === 403) {
                    throw new errors_js_1.AuthenticationError('porkbun', message);
                }
                if (status === 429) {
                    const retryAfter = axiosError.response.headers['retry-after'];
                    throw new errors_js_1.RateLimitError('porkbun', retryAfter ? parseInt(retryAfter, 10) : undefined);
                }
                throw new errors_js_1.RegistrarApiError(this.name, message, status, error);
            }
            if (axiosError.code === 'ECONNABORTED') {
                throw new errors_js_1.RegistrarApiError(this.name, `Request timed out for ${domain}`, undefined, error);
            }
        }
        throw new errors_js_1.RegistrarApiError(this.name, error instanceof Error ? error.message : 'Unknown error', undefined, error instanceof Error ? error : undefined);
    }
    /**
     * Get typical use case for a TLD.
     */
    getTldUseCase(tld) {
        const useCases = {
            com: 'General commercial websites',
            io: 'Tech startups and SaaS products',
            dev: 'Developer tools and portfolios',
            app: 'Mobile and web applications',
            co: 'Companies and startups',
            net: 'Network services and utilities',
            org: 'Non-profit organizations',
            ai: 'AI and machine learning projects',
            xyz: 'Creative and unconventional projects',
        };
        return useCases[tld] || 'General purpose';
    }
    /**
     * Get TLD popularity rating.
     */
    getTldPopularity(tld) {
        const highPopularity = ['com', 'net', 'org', 'io', 'co'];
        const mediumPopularity = ['dev', 'app', 'ai', 'me'];
        if (highPopularity.includes(tld))
            return 'high';
        if (mediumPopularity.includes(tld))
            return 'medium';
        return 'low';
    }
    /**
     * Get TLD category.
     */
    getTldCategory(tld) {
        const countryTlds = ['uk', 'de', 'fr', 'jp', 'cn', 'au', 'ca', 'us'];
        const sponsoredTlds = ['edu', 'gov', 'mil'];
        const newTlds = ['io', 'dev', 'app', 'ai', 'xyz', 'tech', 'cloud'];
        if (countryTlds.includes(tld))
            return 'country';
        if (sponsoredTlds.includes(tld))
            return 'sponsored';
        if (newTlds.includes(tld))
            return 'new';
        return 'generic';
    }
}
exports.PorkbunAdapter = PorkbunAdapter;
/**
 * Singleton instance.
 */
exports.porkbunAdapter = new PorkbunAdapter();
//# sourceMappingURL=porkbun.js.map