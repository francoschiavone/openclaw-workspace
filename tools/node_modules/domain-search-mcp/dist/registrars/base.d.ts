/**
 * Base Registrar Adapter.
 *
 * Abstract class that all registrar adapters extend.
 * Provides common functionality:
 * - Rate limiting (token bucket)
 * - Retry with exponential backoff
 * - Error handling and logging
 */
import type { DomainResult, TLDInfo } from '../types.js';
/**
 * Token bucket rate limiter.
 */
export declare class RateLimiter {
    private tokens;
    private readonly maxTokens;
    private readonly refillRate;
    private lastRefill;
    constructor(maxPerMinute?: number);
    /**
     * Try to consume a token. Returns true if successful.
     */
    tryConsume(): boolean;
    /**
     * Wait until a token is available.
     */
    waitForToken(): Promise<void>;
    /**
     * Refill tokens based on elapsed time.
     */
    private refill;
    /**
     * Get seconds until next token is available.
     */
    getWaitSeconds(): number;
}
/**
 * Abstract base class for registrar adapters.
 */
export declare abstract class RegistrarAdapter {
    /** Human-readable name of the registrar */
    abstract readonly name: string;
    /** Identifier used in results */
    abstract readonly id: string;
    /** Rate limiter for this registrar */
    protected readonly rateLimiter: RateLimiter;
    /** Max retry attempts */
    protected readonly maxRetries: number;
    /** Base delay for exponential backoff (ms) */
    protected readonly baseDelayMs: number;
    /** Request timeout (ms) */
    protected readonly timeoutMs: number;
    constructor(requestsPerMinute?: number);
    /**
     * Check domain availability and get pricing.
     * This is the main method each adapter must implement.
     */
    abstract search(domain: string, tld: string): Promise<DomainResult>;
    /**
     * Get information about a TLD.
     * Optional - not all registrars provide this.
     */
    abstract getTldInfo(tld: string): Promise<TLDInfo | null>;
    /**
     * Check if this adapter is enabled (has required credentials).
     */
    abstract isEnabled(): boolean;
    /**
     * Execute a function with rate limiting.
     */
    protected rateLimitedCall<T>(fn: () => Promise<T>): Promise<T>;
    /**
     * Execute with retry and exponential backoff.
     */
    protected retryWithBackoff<T>(fn: () => Promise<T>, operation: string): Promise<T>;
    /**
     * Create a timeout wrapper for a promise.
     */
    protected withTimeout<T>(promise: Promise<T>, operation: string, timeoutMs?: number): Promise<T>;
    /**
     * Log an error with context.
     */
    protected logError(error: Error, context?: Record<string, unknown>): void;
    /**
     * Create a standardized DomainResult.
     */
    protected createResult(domain: string, tld: string, data: Partial<DomainResult>): DomainResult;
}
//# sourceMappingURL=base.d.ts.map