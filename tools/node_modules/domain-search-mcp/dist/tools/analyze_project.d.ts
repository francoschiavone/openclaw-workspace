/**
 * analyze_project Tool - Extract context from projects for domain suggestions.
 *
 * Analyzes local projects or GitHub repositories to extract:
 * - Project name and description
 * - Keywords from manifest files
 * - Detected industry
 * - Automatic domain suggestions based on context
 */
import { z } from 'zod';
/**
 * Input schema for analyze_project.
 */
export declare const analyzeProjectSchema: z.ZodObject<{
    path: z.ZodString;
    include_source_files: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    suggest_domains: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    tld: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    max_suggestions: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    style: z.ZodDefault<z.ZodOptional<z.ZodEnum<["brandable", "descriptive", "short", "creative"]>>>;
}, "strip", z.ZodTypeAny, {
    path: string;
    style: "creative" | "brandable" | "descriptive" | "short";
    tld: string;
    max_suggestions: number;
    suggest_domains: boolean;
    include_source_files: boolean;
}, {
    path: string;
    style?: "creative" | "brandable" | "descriptive" | "short" | undefined;
    tld?: string | undefined;
    max_suggestions?: number | undefined;
    suggest_domains?: boolean | undefined;
    include_source_files?: boolean | undefined;
}>;
export type AnalyzeProjectInput = z.infer<typeof analyzeProjectSchema>;
/**
 * Tool definition for MCP.
 */
export declare const analyzeProjectTool: {
    name: string;
    description: string;
    inputSchema: {
        type: string;
        properties: {
            path: {
                type: string;
                description: string;
            };
            include_source_files: {
                type: string;
                description: string;
            };
            suggest_domains: {
                type: string;
                description: string;
            };
            tld: {
                type: string;
                description: string;
            };
            max_suggestions: {
                type: string;
                description: string;
            };
            style: {
                type: string;
                enum: string[];
                description: string;
            };
        };
        required: string[];
    };
};
/**
 * Response format for analyze_project.
 */
interface AnalyzeProjectResponse {
    /** Extracted project context */
    project: {
        name: string;
        description?: string;
        keywords: string[];
        detected_industry?: string;
        source: 'local' | 'github';
        repository_url?: string;
    };
    /** Files that were analyzed */
    extracted_from: string[];
    /** Insights about the project */
    insights: string[];
    /** Any warnings */
    warnings: string[];
    /** Domain suggestions if enabled */
    suggestions?: {
        available: Array<{
            domain: string;
            available: boolean;
            score: number;
            source: string;
        }>;
        premium: Array<{
            domain: string;
            available: boolean;
            score: number;
            source: string;
        }>;
        unavailable_count: number;
    };
}
/**
 * Execute the analyze_project tool.
 */
export declare function executeAnalyzeProject(input: AnalyzeProjectInput): Promise<AnalyzeProjectResponse>;
export {};
//# sourceMappingURL=analyze_project.d.ts.map