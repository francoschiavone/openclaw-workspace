"use strict";
/**
 * expiring_domains Tool - Find Domains About to Expire.
 *
 * Queries the federated negative cache for domains approaching
 * their expiration date. Useful for domain investors watching
 * specific domains or looking for opportunities.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.expiringDomainsTool = exports.expiringDomainsSchema = void 0;
exports.executeExpiringDomains = executeExpiringDomains;
const zod_1 = require("zod");
const negative_cache_js_1 = require("../services/negative-cache.js");
const config_js_1 = require("../config.js");
const errors_js_1 = require("../utils/errors.js");
/**
 * Input schema for expiring_domains.
 */
exports.expiringDomainsSchema = zod_1.z.object({
    tlds: zod_1.z
        .array(zod_1.z.string())
        .optional()
        .describe("Filter by TLDs (e.g., ['com', 'io']). Omit to search all TLDs."),
    days: zod_1.z
        .coerce
        .number()
        .int()
        .min(1)
        .max(365)
        .optional()
        .default(30)
        .describe("Find domains expiring within this many days. Defaults to 30."),
    limit: zod_1.z
        .coerce
        .number()
        .int()
        .min(1)
        .max(100)
        .optional()
        .default(25)
        .describe("Maximum results to return (1-100). Defaults to 25."),
    keywords: zod_1.z
        .string()
        .optional()
        .describe("Filter by keywords in domain name (e.g., 'tech' to find tech-related domains)."),
});
/**
 * Tool definition for MCP.
 */
exports.expiringDomainsTool = {
    name: 'expiring_domains',
    description: `Find domains that are about to expire and may become available soon.

Monitors the federated negative cache for domains approaching their expiration date.
Useful for domain investors and those watching specific domains.

Requires NEGATIVE_CACHE_URL to be configured.

Examples:
- expiring_domains(days=30) â†’ Domains expiring in the next 30 days
- expiring_domains(tlds=["com"], days=7) â†’ .com domains expiring within a week
- expiring_domains(keywords="ai") â†’ AI-related domains expiring soon`,
    inputSchema: {
        type: 'object',
        properties: {
            tlds: {
                type: 'array',
                items: { type: 'string' },
                description: "Filter by TLDs (e.g., ['com', 'io']). Omit to search all TLDs.",
            },
            days: {
                type: 'number',
                description: "Find domains expiring within this many days. Defaults to 30.",
            },
            limit: {
                type: 'number',
                description: "Maximum results to return (1-100). Defaults to 25.",
            },
            keywords: {
                type: 'string',
                description: "Filter by keywords in domain name.",
            },
        },
        required: [],
    },
};
/**
 * Execute the expiring_domains tool.
 */
async function executeExpiringDomains(input) {
    try {
        const { tlds, days, limit, keywords } = exports.expiringDomainsSchema.parse(input);
        // Check if negative cache is enabled
        if (!config_js_1.config.negativeCache.enabled) {
            return {
                domains: [],
                total: 0,
                filters: {
                    tlds: tlds || null,
                    days,
                    keywords: keywords || null,
                },
                insights: [
                    'âš ï¸ Federated negative cache is not enabled.',
                    'ðŸ’¡ Set NEGATIVE_CACHE_ENABLED=true and NEGATIVE_CACHE_URL to use this feature.',
                ],
                enabled: false,
            };
        }
        // Query the backend
        const result = await (0, negative_cache_js_1.getExpiringDomains)({
            tlds,
            days,
            limit,
            keywords,
        });
        // Transform results
        const domains = result.domains.map(d => ({
            domain: d.fqdn,
            expires_at: d.expires_at,
            days_until_expiration: d.days_until_expiration,
            tld: d.fqdn.split('.').pop() || '',
        }));
        // Generate insights
        const insights = [];
        if (domains.length > 0) {
            insights.push(`ðŸ” Found ${domains.length} domain${domains.length > 1 ? 's' : ''} expiring within ${days} days`);
            // Group by urgency
            const urgent = domains.filter(d => d.days_until_expiration <= 7);
            const soon = domains.filter(d => d.days_until_expiration > 7 && d.days_until_expiration <= 14);
            if (urgent.length > 0) {
                insights.push(`ðŸ”´ ${urgent.length} domain${urgent.length > 1 ? 's' : ''} expire within 7 days!`);
            }
            if (soon.length > 0) {
                insights.push(`ðŸŸ¡ ${soon.length} domain${soon.length > 1 ? 's' : ''} expire within 14 days`);
            }
            // TLD distribution
            const tldCounts = new Map();
            for (const d of domains) {
                tldCounts.set(d.tld, (tldCounts.get(d.tld) || 0) + 1);
            }
            if (tldCounts.size > 1) {
                const tldStr = Array.from(tldCounts.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([tld, count]) => `.${tld}: ${count}`)
                    .join(', ');
                insights.push(`ðŸ“Š TLD distribution: ${tldStr}`);
            }
        }
        else {
            insights.push(`âŒ No domains found expiring within ${days} days`);
            if (tlds && tlds.length > 0) {
                insights.push(`ðŸ’¡ Try expanding your TLD filter or increasing the days parameter`);
            }
        }
        if (result.total > domains.length) {
            insights.push(`ðŸ“‘ Showing ${domains.length} of ${result.total} total results. Increase limit for more.`);
        }
        return {
            domains,
            total: result.total,
            filters: {
                tlds: tlds || null,
                days,
                keywords: keywords || null,
            },
            insights,
            enabled: true,
        };
    }
    catch (error) {
        throw (0, errors_js_1.wrapError)(error);
    }
}
//# sourceMappingURL=expiring_domains.js.map