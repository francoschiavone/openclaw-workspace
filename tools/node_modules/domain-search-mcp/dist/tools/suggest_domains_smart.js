"use strict";
/**
 * suggest_domains_smart Tool - AI-like Domain Name Suggestions.
 *
 * Advanced domain suggestion engine using semantic analysis,
 * synonym expansion, industry detection, and creative algorithms.
 * No external AI dependencies - fully native implementation.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.suggestDomainsSmartTool = exports.suggestDomainsSmartSchema = void 0;
exports.executeSuggestDomainsSmart = executeSuggestDomainsSmart;
const zod_1 = require("zod");
const domain_search_js_1 = require("../services/domain-search.js");
const errors_js_1 = require("../utils/errors.js");
const semantic_engine_js_1 = require("../utils/semantic-engine.js");
const config_js_1 = require("../config.js");
const logger_js_1 = require("../utils/logger.js");
const qwen_inference_js_1 = require("../services/qwen-inference.js");
const together_inference_js_1 = require("../services/together-inference.js");
const rate_limiter_js_1 = require("../utils/rate-limiter.js");
/**
 * Premium price thresholds by TLD (first year price in USD).
 * If price exceeds threshold, domain is marked as premium.
 */
const PREMIUM_THRESHOLDS = {
    com: 15,
    net: 15,
    org: 15,
    io: 50,
    co: 35,
    ai: 80,
    dev: 20,
    app: 20,
    xyz: 15,
    tech: 50,
    default: 30,
};
/**
 * Detect if a domain is premium based on price.
 */
function isPremiumPrice(tld, price) {
    if (price === null)
        return false;
    const threshold = PREMIUM_THRESHOLDS[tld] || PREMIUM_THRESHOLDS.default;
    return price > threshold;
}
/**
 * Input schema for suggest_domains_smart.
 */
exports.suggestDomainsSmartSchema = zod_1.z.object({
    query: zod_1.z
        .string()
        .min(1)
        .max(200)
        .describe("Search query - can be keywords, business description, or domain name. " +
        "Examples: 'coffee shop seattle', 'ai startup', 'vibecoding'"),
    tld: zod_1.z
        .string()
        .optional()
        .default('com')
        .describe("Primary TLD to check. Defaults to 'com'."),
    industry: zod_1.z
        .enum(['tech', 'startup', 'finance', 'health', 'food', 'creative', 'ecommerce', 'education', 'gaming', 'social'])
        .optional()
        .describe("Industry context for better suggestions. Auto-detected if not provided."),
    style: zod_1.z
        .enum(['brandable', 'descriptive', 'short', 'creative'])
        .optional()
        .default('brandable')
        .describe("Suggestion style: 'brandable' (unique names), 'descriptive' (keyword-based), " +
        "'short' (minimal length), 'creative' (playful combinations)."),
    max_suggestions: zod_1.z
        .coerce
        .number()
        .int()
        .min(1)
        .max(50)
        .optional()
        .default(15)
        .describe("Maximum suggestions to return (1-50). Defaults to 15."),
    include_premium: zod_1.z
        .boolean()
        .optional()
        .default(false)
        .describe("Include premium-priced domains in results. Defaults to false."),
    project_context: zod_1.z
        .object({
        name: zod_1.z.string().optional().describe("Project name"),
        description: zod_1.z.string().optional().describe("Project description"),
        keywords: zod_1.z.array(zod_1.z.string()).optional().describe("Keywords to incorporate"),
        industry: zod_1.z.string().optional().describe("Industry context"),
        repository_url: zod_1.z.string().optional().describe("Repository URL if applicable"),
    })
        .optional()
        .describe("Optional project context for more relevant suggestions. " +
        "Use analyze_project tool to extract this automatically from a codebase."),
});
/**
 * Tool definition for MCP.
 */
exports.suggestDomainsSmartTool = {
    name: 'suggest_domains_smart',
    description: `AI-powered domain name suggestion engine.

Generate creative, brandable domain names from keywords or business descriptions.
Combines multiple intelligent sources for maximum coverage and quality.

Features:
- ZERO-CONFIG: Works out of the box with our fine-tuned Qwen 7B-DPO model
- Domain-specialized fine-tuned model for higher quality suggestions
- Understands natural language queries ("coffee shop in seattle")
- Auto-detects industry for contextual suggestions
- Generates portmanteau/blended names (instagram = instant + telegram)
- Applies modern naming patterns (ly, ify, io, hub, etc.)
- Filters premium domains by default
- Availability verified via Porkbun/RDAP
- Graceful fallback: Fine-tuned Qwen â†’ Semantic engine

Examples:
- suggest_domains_smart("ai customer service") â†’ AI-themed suggestions
- suggest_domains_smart("organic coffee", industry="food") â†’ Food-focused names
- suggest_domains_smart("vibecoding", style="short") â†’ Minimal length names`,
    inputSchema: {
        type: 'object',
        properties: {
            query: {
                type: 'string',
                description: "Keywords, business description, or base domain name.",
            },
            tld: {
                type: 'string',
                description: "TLD to check (e.g., 'com'). Defaults to 'com'.",
            },
            industry: {
                type: 'string',
                enum: ['tech', 'startup', 'finance', 'health', 'food', 'creative', 'ecommerce', 'education', 'gaming', 'social'],
                description: "Industry for contextual suggestions. Auto-detected if omitted.",
            },
            style: {
                type: 'string',
                enum: ['brandable', 'descriptive', 'short', 'creative'],
                description: "Suggestion style preference.",
            },
            max_suggestions: {
                type: 'number',
                description: "Maximum suggestions to return (1-50). Defaults to 15.",
            },
            include_premium: {
                type: 'boolean',
                description: "Include premium domains. Defaults to false.",
            },
            project_context: {
                type: 'object',
                properties: {
                    name: { type: 'string', description: "Project name" },
                    description: { type: 'string', description: "Project description" },
                    keywords: { type: 'array', items: { type: 'string' }, description: "Keywords" },
                    industry: { type: 'string', description: "Industry context" },
                    repository_url: { type: 'string', description: "Repository URL" },
                },
                description: "Project context from analyze_project for better suggestions.",
            },
        },
        required: ['query'],
    },
};
/**
 * Apply style-specific filtering and scoring adjustments.
 */
function applyStyleFilter(suggestions, style, originalQuery) {
    switch (style) {
        case 'short':
            return suggestions
                .filter(s => s.length <= 8)
                .sort((a, b) => a.length - b.length);
        case 'descriptive':
            // Prefer suggestions that contain original words
            const words = (0, semantic_engine_js_1.segmentWords)(originalQuery);
            return suggestions.sort((a, b) => {
                const aMatches = words.filter(w => a.includes(w)).length;
                const bMatches = words.filter(w => b.includes(w)).length;
                return bMatches - aMatches;
            });
        case 'creative':
            // Prefer longer, more unique combinations
            return suggestions
                .filter(s => s.length >= 6)
                .sort((a, b) => {
                const aScore = a.length + (a.match(/[aeiouy]/g)?.length || 0) * 2;
                const bScore = b.length + (b.match(/[aeiouy]/g)?.length || 0) * 2;
                return bScore - aScore;
            });
        case 'brandable':
        default:
            // Balanced approach - pronounceable, medium length
            return suggestions.sort((a, b) => {
                const aScore = (0, semantic_engine_js_1.scoreDomainName)(a, originalQuery);
                const bScore = (0, semantic_engine_js_1.scoreDomainName)(b, originalQuery);
                return bScore - aScore;
            });
    }
}
/**
 * Execute the suggest_domains_smart tool.
 */
async function executeSuggestDomainsSmart(input) {
    try {
        const { query, tld, industry, style, max_suggestions, include_premium, project_context } = exports.suggestDomainsSmartSchema.parse(input);
        // Normalize and analyze input
        const normalizedQuery = query.toLowerCase().trim();
        const detectedWords = (0, semantic_engine_js_1.segmentWords)(normalizedQuery);
        const detectedIndustry = industry || project_context?.industry || (0, semantic_engine_js_1.detectIndustry)(detectedWords);
        // Build Qwen context from project_context if provided
        const qwenContext = project_context ? {
            projectName: project_context.name,
            description: project_context.description,
            industry: project_context.industry || detectedIndustry || undefined,
            keywords: project_context.keywords,
            repositoryUrl: project_context.repository_url,
        } : undefined;
        // Track source statistics
        const sourceStats = {
            qwen_inference: 0,
            together_ai: 0,
            semantic_engine: 0,
        };
        // ========================================
        // STEP 1: Generate suggestions from ALL sources in PARALLEL
        // ========================================
        // AI Source Priority (January 2026 - Zero-Config Design):
        // 1. PRIMARY: VPS fine-tuned Qwen 7B-DPO (llama-server:8000) - FREE, domain-specialized
        // 2. FALLBACK: Together.ai (deprecated BYOK) - 3s delayed start to prefer VPS
        // 3. ALWAYS: Semantic engine (rule-based, offline) - runs in parallel
        // P3 FIX: Rate limit AI inference calls
        (0, rate_limiter_js_1.checkRateLimit)(rate_limiter_js_1.inferenceRateLimiter, 'suggest_domains_smart', 'AI domain suggestions');
        // Common AI options
        const aiOptions = {
            query: normalizedQuery,
            style,
            tld,
            max_suggestions: max_suggestions * 2,
            temperature: style === 'creative' ? 0.9 : 0.7,
            context: qwenContext,
        };
        const aiPromises = [];
        // PRIMARY: VPS fine-tuned Qwen 7B-DPO (starts immediately)
        const qwenClient = (0, qwen_inference_js_1.getQwenClient)();
        if (qwenClient) {
            aiPromises.push(qwenClient.suggest(aiOptions).then((results) => {
                if (!results || results.length === 0) {
                    throw new Error('Empty Qwen results');
                }
                logger_js_1.logger.debug('VPS Qwen completed (parallel)', { count: results.length });
                return { suggestions: results, source: 'qwen_inference' };
            }));
        }
        // FALLBACK: Together.ai (3s delayed start to prefer VPS)
        if ((0, together_inference_js_1.isTogetherConfigured)()) {
            const togetherClient = (0, together_inference_js_1.getTogetherClient)();
            if (togetherClient) {
                aiPromises.push(new Promise((resolve, reject) => {
                    // 3s delay gives VPS priority
                    setTimeout(async () => {
                        try {
                            const results = await togetherClient.suggest(aiOptions);
                            if (!results || results.length === 0) {
                                reject(new Error('Empty Together results'));
                                return;
                            }
                            logger_js_1.logger.debug('Together.ai completed (parallel fallback)', { count: results.length });
                            resolve({ suggestions: results, source: 'together_ai' });
                        }
                        catch (error) {
                            reject(error);
                        }
                    }, 3000);
                }));
            }
        }
        // Semantic engine runs in parallel (instant, offline)
        const semanticPromise = Promise.resolve((0, semantic_engine_js_1.generateSmartSuggestions)(normalizedQuery, {
            maxSuggestions: max_suggestions * 3,
            includePortmanteau: style === 'creative' || style === 'brandable',
            includeSynonyms: style !== 'short',
            includeIndustryTerms: !!detectedIndustry,
            industry: detectedIndustry || undefined,
        }));
        // Race AI sources - first success wins
        let aiSuggestions = [];
        let aiSource = null;
        if (aiPromises.length > 0) {
            try {
                const winner = await Promise.any(aiPromises);
                aiSuggestions = winner.suggestions;
                aiSource = winner.source;
                if (winner.source === 'qwen_inference') {
                    sourceStats.qwen_inference = winner.suggestions.length;
                }
                else {
                    sourceStats.together_ai = winner.suggestions.length;
                }
                logger_js_1.logger.info('AI race winner', {
                    source: winner.source,
                    count: winner.suggestions.length,
                    sample: winner.suggestions.slice(0, 2).map(s => s.name),
                });
            }
            catch (error) {
                // All AI sources failed - AggregateError from Promise.any
                logger_js_1.logger.warn('All AI sources failed, using semantic engine only', {
                    error: error instanceof Error ? error.message : 'unknown',
                });
            }
        }
        // Get semantic results (already completed or completing)
        const semanticSuggestions = await semanticPromise;
        sourceStats.semantic_engine = semanticSuggestions.length;
        // ========================================
        // STEP 2: Merge and deduplicate suggestions
        // ========================================
        // Track which domains came from which source
        const domainSources = new Map();
        // Add AI suggestions first (highest priority - VPS Qwen â†’ Together.ai)
        for (const ais of aiSuggestions) {
            const fullDomain = `${ais.name}.${ais.tld}`.toLowerCase();
            domainSources.set(fullDomain, aiSource || 'semantic_engine');
        }
        // Add semantic suggestions
        const styledSuggestions = applyStyleFilter(semanticSuggestions, style, normalizedQuery);
        for (const name of styledSuggestions) {
            const fullDomain = `${name}.${tld}`.toLowerCase();
            // Don't override AI suggestions
            if (!domainSources.has(fullDomain)) {
                domainSources.set(fullDomain, 'semantic_engine');
            }
        }
        // ========================================
        // STEP 3: Check availability for all suggestions via Porkbun/RDAP
        // ========================================
        const available = [];
        const premium = [];
        let unavailableCount = 0;
        let totalChecked = 0;
        // Build candidate list from all sources
        let candidates = styledSuggestions.slice(0, max_suggestions * 2); // Get extra for pre-filtering
        // Pre-filter known-taken domains from federated negative cache
        if (config_js_1.config.negativeCache.enabled && candidates.length > 0) {
            const beforeCount = candidates.length;
            candidates = await (0, semantic_engine_js_1.filterKnownTakenSuggestions)(candidates, tld);
            const filtered = beforeCount - candidates.length;
            if (filtered > 0) {
                logger_js_1.logger.debug('Smart suggestions pre-filter', {
                    before: beforeCount,
                    after: candidates.length,
                    filtered,
                });
            }
        }
        // Limit after pre-filtering
        candidates = candidates.slice(0, max_suggestions);
        const BATCH_SIZE = 5;
        for (let i = 0; i < candidates.length; i += BATCH_SIZE) {
            const batch = candidates.slice(i, i + BATCH_SIZE);
            const batchResults = await Promise.all(batch.map(async (name) => {
                try {
                    const response = await (0, domain_search_js_1.searchDomain)(name, [tld], undefined, {
                        pricing: { enabled: false, maxQuotes: 0 },
                    });
                    const result = response.results.find((r) => r.domain === `${name}.${tld}`);
                    return { name, result: result || null };
                }
                catch {
                    return { name, result: null };
                }
            }));
            for (const { name, result } of batchResults) {
                totalChecked++;
                if (!result) {
                    unavailableCount++;
                    continue;
                }
                const isPremiumDomain = result.premium || isPremiumPrice(tld, result.price_first_year);
                const fullDomain = `${name}.${tld}`.toLowerCase();
                const suggestion = {
                    domain: fullDomain,
                    available: result.available,
                    price_first_year: result.price_first_year,
                    price_renewal: result.price_renewal,
                    registrar: result.registrar,
                    premium: result.premium || false,
                    premium_detected: isPremiumPrice(tld, result.price_first_year),
                    privacy_included: result.privacy_included || false,
                    score: (0, semantic_engine_js_1.scoreDomainName)(name, normalizedQuery),
                    category: !result.available
                        ? 'unavailable'
                        : isPremiumDomain
                            ? 'premium'
                            : 'standard',
                    source: domainSources.get(fullDomain) || 'semantic_engine',
                };
                if (!result.available) {
                    unavailableCount++;
                }
                else if (isPremiumDomain) {
                    if (include_premium) {
                        premium.push(suggestion);
                    }
                }
                else {
                    available.push(suggestion);
                }
            }
            // Early exit if we have enough available
            if (available.length >= max_suggestions && !include_premium) {
                break;
            }
        }
        // ========================================
        // STEP 4: Sort and finalize results
        // ========================================
        // Sort by score (higher is better)
        available.sort((a, b) => b.score - a.score);
        premium.sort((a, b) => b.score - a.score);
        // Limit results
        const finalAvailable = available.slice(0, max_suggestions);
        const finalPremium = include_premium ? premium.slice(0, Math.floor(max_suggestions / 2)) : [];
        // ========================================
        // STEP 5: Generate insights
        // ========================================
        const insights = [];
        // Source info - AI provider attribution
        if (sourceStats.qwen_inference > 0) {
            insights.push(`ðŸ¤– ${sourceStats.qwen_inference} AI suggestions from fine-tuned Qwen 7B-DPO`);
        }
        else if (sourceStats.together_ai > 0) {
            insights.push(`ðŸ¤– ${sourceStats.together_ai} AI suggestions from Together.ai`);
        }
        insights.push(`ðŸ” Semantic Engine generated ${sourceStats.semantic_engine} suggestions`);
        if (detectedIndustry) {
            insights.push(`ðŸŽ¯ Detected industry: ${detectedIndustry}`);
        }
        if (detectedWords.length > 1) {
            insights.push(`ðŸ“ Parsed keywords: ${detectedWords.join(', ')}`);
        }
        if (finalAvailable.length > 0) {
            insights.push(`âœ… Found ${finalAvailable.length} available domain${finalAvailable.length > 1 ? 's' : ''}`);
            const best = finalAvailable[0];
            const priceStr = best.price_first_year !== null ? `$${best.price_first_year}/yr` : 'via ' + best.registrar;
            insights.push(`â­ Top pick: ${best.domain} (${priceStr})`);
        }
        else {
            insights.push(`âŒ No standard-priced domains available`);
        }
        if (premium.length > 0) {
            insights.push(`ðŸ’Ž ${premium.length} premium domain${premium.length > 1 ? 's' : ''} available`);
        }
        if (finalAvailable.length < 3) {
            insights.push(`ðŸ’¡ Try different keywords or a different TLD (.io, .co, .dev)`);
        }
        // Get related terms for user reference
        const relatedTerms = [];
        for (const word of detectedWords.slice(0, 3)) {
            const synonyms = (0, semantic_engine_js_1.getSynonyms)(word);
            relatedTerms.push(...synonyms.slice(0, 2));
        }
        if (detectedIndustry) {
            const industryTerms = (0, semantic_engine_js_1.getIndustryTerms)(detectedIndustry);
            relatedTerms.push(...industryTerms.slice(0, 4));
        }
        return {
            query: normalizedQuery,
            detected_words: detectedWords,
            detected_industry: detectedIndustry,
            tld,
            style,
            sources: sourceStats,
            total_checked: totalChecked,
            results: {
                available: finalAvailable,
                premium: finalPremium,
                unavailable_count: unavailableCount,
            },
            insights,
            related_terms: [...new Set(relatedTerms)].slice(0, 10),
        };
    }
    catch (error) {
        throw (0, errors_js_1.wrapError)(error);
    }
}
//# sourceMappingURL=suggest_domains_smart.js.map