"use strict";
/**
 * analyze_project Tool - Extract context from projects for domain suggestions.
 *
 * Analyzes local projects or GitHub repositories to extract:
 * - Project name and description
 * - Keywords from manifest files
 * - Detected industry
 * - Automatic domain suggestions based on context
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzeProjectTool = exports.analyzeProjectSchema = void 0;
exports.executeAnalyzeProject = executeAnalyzeProject;
const zod_1 = require("zod");
const project_analyzer_js_1 = require("../services/project-analyzer.js");
const suggest_domains_smart_js_1 = require("./suggest_domains_smart.js");
const errors_js_1 = require("../utils/errors.js");
const logger_js_1 = require("../utils/logger.js");
/**
 * Input schema for analyze_project.
 */
exports.analyzeProjectSchema = zod_1.z.object({
    path: zod_1.z
        .string()
        .min(1)
        .describe("Path to analyze. Can be a local directory path (e.g., '/path/to/project') " +
        "or a GitHub URL (e.g., 'https://github.com/user/repo')."),
    include_source_files: zod_1.z
        .boolean()
        .optional()
        .default(false)
        .describe("Scan source files for additional keywords (slower). Defaults to false."),
    suggest_domains: zod_1.z
        .boolean()
        .optional()
        .default(true)
        .describe("Automatically generate domain suggestions based on extracted context. Defaults to true."),
    tld: zod_1.z
        .string()
        .optional()
        .default('com')
        .describe("Primary TLD for suggestions. Defaults to 'com'."),
    max_suggestions: zod_1.z
        .coerce
        .number()
        .int()
        .min(1)
        .max(30)
        .optional()
        .default(10)
        .describe("Maximum domain suggestions to return (1-30). Defaults to 10."),
    style: zod_1.z
        .enum(['brandable', 'descriptive', 'short', 'creative'])
        .optional()
        .default('brandable')
        .describe("Suggestion style: 'brandable' (invented words), 'descriptive' (keyword-based), " +
        "'short' (minimal), 'creative' (playful). Defaults to 'brandable'."),
});
/**
 * Tool definition for MCP.
 */
exports.analyzeProjectTool = {
    name: 'analyze_project',
    description: `Analyze a local project or GitHub repository to extract context for domain suggestions.

This tool scans project manifest files (package.json, pyproject.toml, Cargo.toml, go.mod)
and README files to understand your project, then generates relevant domain name suggestions.

**Use Cases:**
1. Find a domain for your existing codebase
2. Get domain ideas that match your project's identity
3. Analyze any GitHub repo for branding inspiration

**Supported Projects:**
- Node.js (package.json)
- Python (pyproject.toml, setup.py)
- Rust (Cargo.toml)
- Go (go.mod)
- Any project with README.md

**Examples:**
- analyze_project("/path/to/my-app") → Analyzes local project
- analyze_project("https://github.com/vercel/next.js") → Analyzes GitHub repo
- analyze_project("/my-project", suggest_domains=true, style="short") → Short brandable names`,
    inputSchema: {
        type: 'object',
        properties: {
            path: {
                type: 'string',
                description: "Local path or GitHub URL to analyze.",
            },
            include_source_files: {
                type: 'boolean',
                description: "Scan source files for keywords. Defaults to false.",
            },
            suggest_domains: {
                type: 'boolean',
                description: "Auto-generate domain suggestions. Defaults to true.",
            },
            tld: {
                type: 'string',
                description: "Primary TLD for suggestions. Defaults to 'com'.",
            },
            max_suggestions: {
                type: 'number',
                description: "Maximum suggestions (1-30). Defaults to 10.",
            },
            style: {
                type: 'string',
                enum: ['brandable', 'descriptive', 'short', 'creative'],
                description: "Suggestion style preference.",
            },
        },
        required: ['path'],
    },
};
/**
 * Execute the analyze_project tool.
 */
async function executeAnalyzeProject(input) {
    try {
        const validated = exports.analyzeProjectSchema.parse(input);
        const { path, include_source_files, suggest_domains, tld, max_suggestions, style } = validated;
        logger_js_1.logger.info('Analyzing project', { path, include_source_files, suggest_domains });
        // Analyze the project
        let analysis;
        try {
            analysis = await (0, project_analyzer_js_1.analyzeProject)(path, { includeSourceFiles: include_source_files });
        }
        catch (error) {
            throw new Error(`Failed to analyze project: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
        // Build response
        const response = {
            project: {
                name: analysis.project.name,
                description: analysis.project.description,
                keywords: analysis.project.keywords,
                detected_industry: analysis.project.industry,
                source: analysis.project.source,
                repository_url: analysis.project.repositoryUrl,
            },
            extracted_from: analysis.extractedFrom,
            insights: analysis.insights,
            warnings: analysis.warnings,
        };
        // Generate domain suggestions if enabled
        if (suggest_domains) {
            // Build query from project context
            const queryParts = [];
            // Add project name (segmented if compound)
            if (analysis.project.name) {
                queryParts.push(analysis.project.name);
            }
            // Add top keywords
            if (analysis.project.keywords.length > 0) {
                queryParts.push(...analysis.project.keywords.slice(0, 3));
            }
            const query = queryParts.join(' ');
            // Build context for Qwen
            const context = {
                projectName: analysis.project.name,
                description: analysis.project.description,
                industry: analysis.project.industry,
                keywords: analysis.project.keywords,
                brandWords: analysis.project.brandWords,
                repositoryUrl: analysis.project.repositoryUrl,
            };
            logger_js_1.logger.debug('Generating domain suggestions with context', {
                query,
                industry: context.industry,
                keywords: context.keywords?.length || 0,
            });
            try {
                // Use suggest_domains_smart with project context
                const suggestResult = await (0, suggest_domains_smart_js_1.executeSuggestDomainsSmart)({
                    query,
                    tld,
                    industry: context.industry,
                    style,
                    max_suggestions,
                    include_premium: false,
                });
                response.suggestions = {
                    available: suggestResult.results.available.map(s => ({
                        domain: s.domain,
                        available: s.available,
                        score: s.score,
                        source: s.source,
                    })),
                    premium: suggestResult.results.premium.map(s => ({
                        domain: s.domain,
                        available: s.available,
                        score: s.score,
                        source: s.source,
                    })),
                    unavailable_count: suggestResult.results.unavailable_count,
                };
                // Add suggestion insights
                response.insights.push(`Generated ${suggestResult.results.available.length} domain suggestions`);
                if (suggestResult.results.available.length > 0) {
                    response.insights.push(`Top domain: ${suggestResult.results.available[0].domain}`);
                }
            }
            catch (error) {
                response.warnings.push(`Failed to generate suggestions: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        }
        return response;
    }
    catch (error) {
        throw (0, errors_js_1.wrapError)(error);
    }
}
//# sourceMappingURL=analyze_project.js.map