"use strict";
/**
 * RDAP (Registration Data Access Protocol) Fallback.
 *
 * RFC 7480 - Modern replacement for WHOIS.
 * Provides availability status only (no pricing).
 * Public API - no authentication required.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkRdap = checkRdap;
exports.isRdapAvailable = isRdapAvailable;
exports.prewarmRdapBootstrap = prewarmRdapBootstrap;
const axios_1 = __importDefault(require("axios"));
const zod_1 = require("zod");
const logger_js_1 = require("../utils/logger.js");
const errors_js_1 = require("../utils/errors.js");
const cache_js_1 = require("../utils/cache.js");
const concurrency_js_1 = require("../utils/concurrency.js");
const adaptive_concurrency_js_1 = require("../utils/adaptive-concurrency.js");
const whois_js_1 = require("./whois.js");
// ═══════════════════════════════════════════════════════════════════════════
// Zod Schemas for RDAP Response Validation (RFC 7483)
// SECURITY: Validate RDAP responses to prevent unexpected data
// ═══════════════════════════════════════════════════════════════════════════
/**
 * vCard array element schema.
 * vCard format: ["property", {}, "type", value]
 */
const VCardPropertySchema = zod_1.z.tuple([
    zod_1.z.string(), // property name (e.g., "fn")
    zod_1.z.record(zod_1.z.unknown()), // parameters (usually empty {})
    zod_1.z.string(), // type (e.g., "text")
    zod_1.z.union([zod_1.z.string(), zod_1.z.array(zod_1.z.string())]), // value
]).or(zod_1.z.array(zod_1.z.unknown())); // Allow flexible arrays for compatibility
/**
 * Entity schema (registrar, registrant, etc.)
 */
const RdapEntitySchema = zod_1.z.object({
    roles: zod_1.z.array(zod_1.z.string()).optional(),
    vcardArray: zod_1.z.tuple([
        zod_1.z.literal('vcard'),
        zod_1.z.array(VCardPropertySchema),
    ]).optional(),
}).passthrough(); // Allow additional RDAP fields
/**
 * RDAP event schema (registration, expiration, etc.)
 */
const RdapEventSchema = zod_1.z.object({
    eventAction: zod_1.z.string(),
    eventDate: zod_1.z.string(),
}).passthrough();
/**
 * Main RDAP domain response schema.
 */
const RdapDomainResponseSchema = zod_1.z.object({
    objectClassName: zod_1.z.string(),
    ldhName: zod_1.z.string().optional(),
    entities: zod_1.z.array(RdapEntitySchema).optional(),
    events: zod_1.z.array(RdapEventSchema).optional(),
}).passthrough(); // Allow additional RDAP fields
/**
 * RDAP bootstrap URLs for different TLDs.
 */
const RDAP_BOOTSTRAP = 'https://data.iana.org/rdap/dns.json';
const RDAP_BOOTSTRAP_TTL_SECONDS = 86400;
const RDAP_TIMEOUT_MS = 800;
const RDAP_ERROR_TTL_MS = 10_000;
const RDAP_GLOBAL_CONCURRENCY = 30;
const RDAP_HOST_CONCURRENCY = 2;
/**
 * TLDs where RDAP 404 responses are UNRELIABLE.
 *
 * For these TLDs, RDAP may return 404 for premium/reserved domains
 * that are actually registered. We use WHOIS as secondary verification.
 *
 * Known issues:
 * - .ai: Premium domains return 404 from RDAP but are registered
 * - .io: Some reserved domains show as 404
 * - .sh: Shares infrastructure with .ai/.io, same issue
 * - .ac: Same registry as .ai/.io/.sh
 */
const UNRELIABLE_RDAP_TLDS = new Set(['ai', 'io', 'sh', 'ac']);
/**
 * Fallback RDAP servers for common TLDs.
 * Expanded to include popular gTLDs and ccTLDs.
 */
const RDAP_SERVERS = {
    // Generic TLDs (Verisign)
    com: 'https://rdap.verisign.com/com/v1',
    net: 'https://rdap.verisign.com/net/v1',
    cc: 'https://rdap.verisign.com/cc/v1',
    tv: 'https://rdap.verisign.com/tv/v1',
    name: 'https://rdap.verisign.com/name/v1',
    // Generic TLDs (Other registries)
    org: 'https://rdap.publicinterestregistry.org/rdap/org',
    info: 'https://rdap.afilias.net/rdap/info',
    biz: 'https://rdap.nic.biz',
    xyz: 'https://rdap.nic.xyz',
    club: 'https://rdap.nic.club',
    online: 'https://rdap.nic.online',
    site: 'https://rdap.nic.site',
    tech: 'https://rdap.nic.tech',
    store: 'https://rdap.nic.store',
    // Google TLDs
    dev: 'https://rdap.nic.google/domain',
    app: 'https://rdap.nic.google/domain',
    page: 'https://rdap.nic.google/domain',
    how: 'https://rdap.nic.google/domain',
    new: 'https://rdap.nic.google/domain',
    // Country-code TLDs (ccTLDs)
    io: 'https://rdap.nic.io/domain',
    co: 'https://rdap.nic.co/domain',
    ai: 'https://rdap.nic.ai/domain',
    me: 'https://rdap.nic.me/domain',
    sh: 'https://rdap.nic.sh/domain',
    ac: 'https://rdap.nic.ac/domain',
    gg: 'https://rdap.nic.gg/domain',
    im: 'https://rdap.nic.im/domain',
    // European ccTLDs
    eu: 'https://rdap.eurid.eu/domain',
    de: 'https://rdap.denic.de/domain',
    nl: 'https://rdap.sidn.nl',
    uk: 'https://rdap.nominet.uk/uk',
    ch: 'https://rdap.nic.ch',
    se: 'https://rdap.iis.se/domain',
    fi: 'https://rdap.traficom.fi/domain',
    cz: 'https://rdap.nic.cz',
    pl: 'https://rdap.dns.pl',
    // Other popular ccTLDs
    ca: 'https://rdap.ca.fury.ca/rdap',
    au: 'https://rdap.auda.org.au',
    nz: 'https://rdap.dnc.org.nz',
    jp: 'https://rdap.jprs.jp/rdap',
    kr: 'https://rdap.kisa.or.kr',
    in: 'https://rdap.registry.in',
    br: 'https://rdap.registro.br',
    // Specialty TLDs
    crypto: 'https://rdap.nic.crypto',
    cloud: 'https://rdap.nic.cloud',
    design: 'https://rdap.nic.design',
    agency: 'https://rdap.nic.agency',
};
/**
 * Cache for RDAP bootstrap data (IANA).
 */
const rdapBootstrapCache = new cache_js_1.TtlCache(RDAP_BOOTSTRAP_TTL_SECONDS, 2);
let rdapBootstrapFallback = null;
const rdapErrorCache = new cache_js_1.TtlCache(10, 5000);
const rdapGlobalLimiter = new adaptive_concurrency_js_1.AdaptiveConcurrencyLimiter({
    name: 'rdap_global',
    minConcurrency: 10,
    maxConcurrency: RDAP_GLOBAL_CONCURRENCY,
    initialConcurrency: 20,
    errorThreshold: 0.15, // 15% error rate triggers decrease
    latencyThresholdMs: 600, // RDAP timeout is 800ms, trigger at 600
    windowMs: 30_000, // 30 second window
    minSamples: 20, // Need 20 samples before adjusting
    evaluationIntervalMs: 10_000, // Evaluate every 10 seconds
});
const rdapHostLimiter = new concurrency_js_1.KeyedLimiter(RDAP_HOST_CONCURRENCY);
/**
 * Get the RDAP server URL for a TLD.
 */
async function getRdapServer(tld) {
    // Check hardcoded servers first
    if (RDAP_SERVERS[tld]) {
        return RDAP_SERVERS[tld];
    }
    const cached = rdapBootstrapCache.get('bootstrap');
    if (cached) {
        return cached[tld] || null;
    }
    // Try to fetch from IANA bootstrap
    try {
        const response = await axios_1.default.get(RDAP_BOOTSTRAP, { timeout: 5000 });
        const map = {};
        for (const [tlds, servers] of response.data.services) {
            for (const t of tlds) {
                map[t] = servers[0] || '';
            }
        }
        rdapBootstrapCache.set('bootstrap', map);
        rdapBootstrapFallback = map;
        return map[tld] || null;
    }
    catch {
        logger_js_1.logger.debug('Failed to fetch RDAP bootstrap', { tld });
        if (rdapBootstrapFallback) {
            return rdapBootstrapFallback[tld] || null;
        }
        return null;
    }
}
/**
 * Safely extract registrar name from vCard array.
 * SECURITY: Validates array bounds and types before access.
 */
function extractRegistrarFromVCard(vcardArray) {
    try {
        // vcardArray should be ["vcard", [...properties]]
        if (!Array.isArray(vcardArray) || vcardArray.length < 2) {
            return undefined;
        }
        const properties = vcardArray[1];
        if (!Array.isArray(properties)) {
            return undefined;
        }
        // Find the "fn" (formatted name) property
        for (const prop of properties) {
            if (!Array.isArray(prop) || prop.length < 4) {
                continue;
            }
            const [propName, , , propValue] = prop;
            if (propName === 'fn' && typeof propValue === 'string') {
                return propValue;
            }
        }
        return undefined;
    }
    catch (error) {
        logger_js_1.logger.debug('Failed to extract registrar from vCard', {
            error: error instanceof Error ? error.message : String(error),
        });
        return undefined;
    }
}
/**
 * Parse RDAP response to determine availability and extract dates.
 * SECURITY: Validates response with Zod schema before processing.
 */
function parseRdapResponse(data) {
    if (!data || typeof data !== 'object') {
        return { available: false };
    }
    // Validate with Zod schema
    const parseResult = RdapDomainResponseSchema.safeParse(data);
    if (!parseResult.success) {
        logger_js_1.logger.debug('RDAP response validation failed', {
            errors: parseResult.error.errors.slice(0, 3), // Limit logged errors
        });
        // Still try to extract basic info even if validation fails
        const record = data;
        if (record.objectClassName === 'domain') {
            return { available: false };
        }
        return { available: false };
    }
    const validated = parseResult.data;
    // If we got a domain record, it's registered (not available)
    if (validated.objectClassName === 'domain') {
        let registrar;
        let registeredAt;
        let expiresAt;
        // Safely extract registrar info
        if (validated.entities) {
            for (const entity of validated.entities) {
                if (entity.roles?.includes('registrar') && entity.vcardArray) {
                    registrar = extractRegistrarFromVCard(entity.vcardArray);
                    if (registrar)
                        break;
                }
            }
        }
        // Extract event dates (registration, expiration, last changed)
        if (validated.events) {
            for (const event of validated.events) {
                const action = event.eventAction.toLowerCase();
                if (action === 'registration' || action === 'created') {
                    registeredAt = event.eventDate;
                }
                else if (action === 'expiration') {
                    expiresAt = event.eventDate;
                }
            }
        }
        return { available: false, registrar, registeredAt, expiresAt };
    }
    return { available: false };
}
/**
 * Check domain availability using RDAP.
 */
async function checkRdap(domain, tld) {
    const fullDomain = `${domain}.${tld}`;
    logger_js_1.logger.debug('RDAP check', { domain: fullDomain });
    const errorKey = `rdap:${fullDomain.toLowerCase()}`;
    if (rdapErrorCache.has(errorKey)) {
        throw new errors_js_1.RegistrarApiError('rdap', 'Recent RDAP failure, backing off');
    }
    const server = await getRdapServer(tld);
    if (!server) {
        throw new errors_js_1.RegistrarApiError('rdap', `No RDAP server found for .${tld}`);
    }
    const url = `${server}/domain/${fullDomain}`;
    let serverHost = server;
    try {
        serverHost = new URL(server).hostname;
    }
    catch {
        // Leave serverHost as-is if URL parsing fails.
    }
    try {
        const response = await rdapGlobalLimiter.run(() => rdapHostLimiter.run(serverHost, () => axios_1.default.get(url, {
            timeout: RDAP_TIMEOUT_MS,
            headers: {
                Accept: 'application/rdap+json',
            },
            // Don't throw on 404 - that means available
            validateStatus: (status) => status < 500,
        })));
        // 404 = domain not found = potentially available
        if (response.status === 404) {
            // For unreliable TLDs (e.g., .ai), verify with WHOIS before confirming
            // RDAP returns 404 for premium/reserved domains that are actually registered
            if (UNRELIABLE_RDAP_TLDS.has(tld)) {
                logger_js_1.logger.debug('RDAP 404 for unreliable TLD, verifying with WHOIS', {
                    domain: fullDomain,
                    tld,
                });
                try {
                    const whoisResult = await (0, whois_js_1.checkWhois)(domain, tld);
                    if (!whoisResult.available) {
                        logger_js_1.logger.debug('RDAP false positive detected - WHOIS says registered', {
                            domain: fullDomain,
                        });
                        return whoisResult; // Domain is actually taken
                    }
                    // Both RDAP and WHOIS agree - domain is available
                    logger_js_1.logger.debug('WHOIS confirmed availability', { domain: fullDomain });
                }
                catch (error) {
                    // WHOIS failed - default to NOT available (fail-safe)
                    logger_js_1.logger.warn('WHOIS verification failed for unreliable TLD, assuming not available', {
                        domain: fullDomain,
                        error: error instanceof Error ? error.message : String(error),
                    });
                    return createRdapResult(domain, tld, false);
                }
            }
            return createRdapResult(domain, tld, true);
        }
        // 200 = domain found = not available
        if (response.status === 200) {
            const parsed = parseRdapResponse(response.data);
            return createRdapResult(domain, tld, parsed.available, {
                registeredAt: parsed.registeredAt,
                expiresAt: parsed.expiresAt,
            });
        }
        throw new errors_js_1.RegistrarApiError('rdap', `Unexpected response: HTTP ${response.status}`);
    }
    catch (error) {
        if (axios_1.default.isAxiosError(error)) {
            const axiosError = error;
            if (axiosError.code === 'ECONNABORTED') {
                rdapErrorCache.set(errorKey, true, RDAP_ERROR_TTL_MS);
                throw new errors_js_1.TimeoutError('RDAP lookup', RDAP_TIMEOUT_MS);
            }
            // 404 = potentially available (same logic as above)
            if (axiosError.response?.status === 404) {
                if (UNRELIABLE_RDAP_TLDS.has(tld)) {
                    try {
                        const whoisResult = await (0, whois_js_1.checkWhois)(domain, tld);
                        if (!whoisResult.available) {
                            return whoisResult; // Domain is actually taken
                        }
                    }
                    catch {
                        // WHOIS failed - default to NOT available (fail-safe)
                        return createRdapResult(domain, tld, false);
                    }
                }
                return createRdapResult(domain, tld, true);
            }
            rdapErrorCache.set(errorKey, true, RDAP_ERROR_TTL_MS);
            throw new errors_js_1.RegistrarApiError('rdap', axiosError.message, axiosError.response?.status, error);
        }
        rdapErrorCache.set(errorKey, true, RDAP_ERROR_TTL_MS);
        throw new errors_js_1.RegistrarApiError('rdap', error instanceof Error ? error.message : 'Unknown error');
    }
}
/**
 * Calculate days until expiration from an ISO date string.
 */
function calculateDaysUntilExpiration(expiresAt) {
    try {
        const expirationDate = new Date(expiresAt);
        const now = new Date();
        const diffMs = expirationDate.getTime() - now.getTime();
        const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
        return diffDays;
    }
    catch {
        return undefined;
    }
}
/**
 * Create a standardized result from RDAP.
 */
function createRdapResult(domain, tld, available, dates) {
    const result = {
        domain: `${domain}.${tld}`,
        available,
        premium: false, // RDAP doesn't tell us about premium status
        price_first_year: null, // RDAP doesn't provide pricing
        price_renewal: null,
        currency: 'USD',
        privacy_included: false,
        transfer_price: null,
        registrar: 'unknown',
        source: 'rdap',
        checked_at: new Date().toISOString(),
    };
    // Add registration and expiration dates if available
    if (dates?.registeredAt) {
        result.registered_at = dates.registeredAt;
    }
    if (dates?.expiresAt) {
        result.expires_at = dates.expiresAt;
        result.days_until_expiration = calculateDaysUntilExpiration(dates.expiresAt);
    }
    return result;
}
/**
 * Check if RDAP is available for a TLD (synchronous check).
 * Uses hardcoded servers only for quick check.
 */
function isRdapAvailable(tld) {
    // Use hardcoded servers for sync check
    // The async bootstrap will be tried during actual lookup
    return RDAP_SERVERS[tld] !== undefined;
}
/**
 * Pre-warm the RDAP bootstrap cache.
 *
 * Call this during server startup to avoid 5s cold-start latency
 * on the first RDAP lookup. Runs in background, doesn't block startup.
 *
 * @returns Promise that resolves when bootstrap is cached (or fails gracefully)
 */
async function prewarmRdapBootstrap() {
    try {
        // Trigger bootstrap fetch by looking up a TLD not in hardcoded list
        // This forces getRdapServer to fetch from IANA
        await getRdapServer('xyz');
        logger_js_1.logger.info('RDAP bootstrap pre-warmed successfully');
    }
    catch (error) {
        // Non-fatal - first lookup will retry
        logger_js_1.logger.warn('RDAP bootstrap pre-warm failed', {
            error: error instanceof Error ? error.message : String(error),
        });
    }
}
//# sourceMappingURL=rdap.js.map