"use strict";
/**
 * Pricing API client (backend).
 *
 * This MCP does NOT ship registrar secrets. Pricing is retrieved from a
 * centralized backend (Vercel) that owns the registrar API keys.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchPricingQuote = fetchPricingQuote;
exports.fetchPricingCompare = fetchPricingCompare;
const config_js_1 = require("../config.js");
const logger_js_1 = require("../utils/logger.js");
const adaptive_concurrency_js_1 = require("../utils/adaptive-concurrency.js");
const cache_js_1 = require("../utils/cache.js");
const pricingLimiter = new adaptive_concurrency_js_1.AdaptiveConcurrencyLimiter({
    name: 'pricing_api',
    minConcurrency: 2,
    maxConcurrency: config_js_1.config.pricingApi.concurrency * 2, // Allow scaling up to 2x config
    initialConcurrency: config_js_1.config.pricingApi.concurrency,
    errorThreshold: 0.1, // 10% error rate triggers decrease
    latencyThresholdMs: 3000, // Pricing API can be slow, 3s threshold
    windowMs: 60_000, // 1 minute window (less traffic than RDAP)
    minSamples: 10, // Need 10 samples before adjusting
    evaluationIntervalMs: 15_000, // Evaluate every 15 seconds
});
const pricingCache = new cache_js_1.TtlCache(config_js_1.config.cache.pricingTtl, 5000);
function normalizeBaseUrl(baseUrl) {
    if (!baseUrl)
        return null;
    return baseUrl.replace(/\/+$/, '');
}
function buildHeaders() {
    const headers = {
        'Content-Type': 'application/json',
    };
    if (config_js_1.config.pricingApi.token) {
        headers.Authorization = `Bearer ${config_js_1.config.pricingApi.token}`;
    }
    return headers;
}
async function fetchJson(url, body, timeoutMs) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);
    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: buildHeaders(),
            body: JSON.stringify(body),
            signal: controller.signal,
        });
        const text = await response.text();
        let json = null;
        if (text) {
            try {
                json = JSON.parse(text);
            }
            catch {
                json = null;
            }
        }
        return { ok: response.ok, status: response.status, json };
    }
    finally {
        clearTimeout(timeout);
    }
}
async function fetchPricingQuote(fqdn) {
    if (!config_js_1.config.pricingApi.enabled)
        return null;
    const baseUrl = normalizeBaseUrl(config_js_1.config.pricingApi.baseUrl);
    if (!baseUrl)
        return null;
    const cacheKey = `quote:${fqdn.toLowerCase()}`;
    const cached = pricingCache.get(cacheKey);
    if (cached)
        return cached;
    return pricingLimiter.run(async () => {
        try {
            const { ok, json } = await fetchJson(`${baseUrl}/api/quote`, { fqdn }, config_js_1.config.pricingApi.timeoutMs);
            if (!json || typeof json !== 'object') {
                return null;
            }
            const payload = json;
            if (payload.domain) {
                pricingCache.set(cacheKey, payload);
            }
            if (!ok) {
                logger_js_1.logger.debug('Pricing API returned non-200', { fqdn, status: payload.quote_status });
            }
            return payload;
        }
        catch (error) {
            logger_js_1.logger.warn('Pricing API quote failed', {
                fqdn,
                error: error instanceof Error ? error.message : String(error),
            });
            return null;
        }
    });
}
async function fetchPricingCompare(domain, tld, registrars) {
    if (!config_js_1.config.pricingApi.enabled)
        return null;
    const baseUrl = normalizeBaseUrl(config_js_1.config.pricingApi.baseUrl);
    if (!baseUrl)
        return null;
    return pricingLimiter.run(async () => {
        try {
            const { json } = await fetchJson(`${baseUrl}/api/compare`, {
                domain,
                tld,
                registrars: registrars && registrars.length > 0 ? registrars : undefined,
            }, config_js_1.config.pricingApi.timeoutMs);
            if (!json || typeof json !== 'object') {
                return null;
            }
            return json;
        }
        catch (error) {
            logger_js_1.logger.warn('Pricing API compare failed', {
                domain: `${domain}.${tld}`,
                error: error instanceof Error ? error.message : String(error),
            });
            return null;
        }
    });
}
//# sourceMappingURL=pricing-api.js.map