/**
 * Qwen Inference API client.
 *
 * Optional AI-powered domain suggestions using fine-tuned Qwen 2.5-7B model.
 * Falls back gracefully if endpoint is not configured or unavailable.
 *
 * This MCP does NOT require Qwen to function - it's an optional enhancement
 * for self-hosted users who deploy the inference server on their VPS.
 */
import { z } from 'zod';
/**
 * Domain suggestion from Qwen model.
 */
export declare const QwenDomainSchema: z.ZodObject<{
    name: z.ZodString;
    tld: z.ZodString;
    reason: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    name: string;
    tld: string;
    reason?: string | undefined;
}, {
    name: string;
    tld: string;
    reason?: string | undefined;
}>;
export type QwenDomain = z.infer<typeof QwenDomainSchema>;
/**
 * Request payload to Qwen inference API.
 */
export declare const QwenRequestSchema: z.ZodObject<{
    prompt: z.ZodString;
    style: z.ZodOptional<z.ZodEnum<["brandable", "descriptive", "short", "creative"]>>;
    max_tokens: z.ZodOptional<z.ZodNumber>;
    temperature: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    prompt: string;
    style?: "creative" | "brandable" | "descriptive" | "short" | undefined;
    max_tokens?: number | undefined;
    temperature?: number | undefined;
}, {
    prompt: string;
    style?: "creative" | "brandable" | "descriptive" | "short" | undefined;
    max_tokens?: number | undefined;
    temperature?: number | undefined;
}>;
export type QwenRequest = z.infer<typeof QwenRequestSchema>;
/**
 * Response from Qwen inference API.
 */
export declare const QwenResponseSchema: z.ZodObject<{
    domains: z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        tld: z.ZodString;
        reason: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        tld: string;
        reason?: string | undefined;
    }, {
        name: string;
        tld: string;
        reason?: string | undefined;
    }>, "many">;
    raw_response: z.ZodString;
    inference_time_ms: z.ZodNumber;
    cached: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    domains: {
        name: string;
        tld: string;
        reason?: string | undefined;
    }[];
    raw_response: string;
    inference_time_ms: number;
    cached: boolean;
}, {
    domains: {
        name: string;
        tld: string;
        reason?: string | undefined;
    }[];
    raw_response: string;
    inference_time_ms: number;
    cached: boolean;
}>;
export type QwenResponse = z.infer<typeof QwenResponseSchema>;
/**
 * Project or idea context for more relevant domain suggestions.
 */
export interface QwenContext {
    /** Project or business description */
    description?: string;
    /** Detected or specified industry */
    industry?: string;
    /** Keywords to blend or incorporate */
    keywords?: string[];
    /** Inspiration words for the brand */
    brandWords?: string[];
    /** Minimum domain name length */
    minLength?: number;
    /** Maximum domain name length */
    maxLength?: number;
    /** Project name (if analyzing a codebase) */
    projectName?: string;
    /** Repository URL (for context) */
    repositoryUrl?: string;
}
/**
 * Options for Qwen suggestion request.
 */
export interface QwenSuggestOptions {
    query: string;
    style?: 'brandable' | 'descriptive' | 'short' | 'creative';
    tld?: string;
    max_suggestions?: number;
    temperature?: number;
    /** Additional context for more relevant suggestions */
    context?: QwenContext;
}
/**
 * Custom error for Qwen inference failures.
 */
export declare class QwenInferenceError extends Error {
    readonly code: 'TIMEOUT' | 'CONNECTION_REFUSED' | 'INVALID_RESPONSE' | 'SERVER_ERROR' | 'NOT_CONFIGURED';
    readonly statusCode?: number | undefined;
    constructor(message: string, code: 'TIMEOUT' | 'CONNECTION_REFUSED' | 'INVALID_RESPONSE' | 'SERVER_ERROR' | 'NOT_CONFIGURED', statusCode?: number | undefined);
}
/**
 * Qwen Inference API client with retry logic and caching.
 */
export declare class QwenInferenceClient {
    private readonly endpoint;
    private readonly apiKey?;
    private readonly timeoutMs;
    private readonly maxRetries;
    private readonly cache;
    private readonly circuitBreaker;
    constructor(endpoint: string, options?: {
        apiKey?: string;
        timeoutMs?: number;
        maxRetries?: number;
        cacheTtl?: number;
    });
    /**
     * Generate domain suggestions using Qwen model.
     *
     * Returns suggestions or null if Qwen is unavailable.
     * Graceful degradation - caller should fall back to other sources.
     */
    suggest(options: QwenSuggestOptions): Promise<QwenDomain[] | null>;
    /**
     * Build comprehensive prompt for Qwen model based on style and context.
     *
     * Uses structured blocks to guide the model toward generating
     * truly inventive, brandable domain names.
     */
    private _buildPrompt;
    /**
     * Build the system instruction block explaining techniques and style.
     */
    private _buildSystemBlock;
    /**
     * Build the context block from project/idea information.
     */
    private _buildContextBlock;
    /**
     * Build the task block specifying what to generate.
     */
    private _buildTaskBlock;
    /**
     * Build the output format specification block.
     */
    private _buildFormatBlock;
    /**
     * Calculate max_tokens based on number of suggestions and style.
     *
     * Token requirements vary by style:
     * - short: ~30 tokens (4-7 char names, brief reasons)
     * - brandable: ~50 tokens (invented names, medium reasons)
     * - descriptive: ~60 tokens (compound words, detailed reasons)
     * - creative: ~70 tokens (wordplay, artistic explanations)
     *
     * Style-aware calculation reduces costs by 20-30% on average.
     */
    private _calculateMaxTokens;
    /**
     * Parse domain names from model-generated text.
     *
     * Matches the fine-tuned model's output format:
     * - domain.tld â€” Reason
     * - domain.tld - Reason
     */
    private _parseDomainsFromText;
    /**
     * Make HTTP request with timeout and error handling.
     */
    private _makeRequest;
    /**
     * Make request with exponential backoff retry.
     *
     * Retries on 5xx errors and timeouts, no retry on 4xx errors.
     */
    private _makeRequestWithRetry;
}
/**
 * Get Qwen client instance (singleton).
 *
 * Returns null if Qwen is not configured - caller should fall back to other sources.
 */
export declare function getQwenClient(): QwenInferenceClient | null;
//# sourceMappingURL=qwen-inference.d.ts.map