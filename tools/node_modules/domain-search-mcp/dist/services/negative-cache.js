"use strict";
/**
 * Federated Negative Cache Client.
 *
 * Reports taken domains to a central backend and queries known-taken domains
 * for pre-filtering suggestions. This reduces redundant availability checks
 * by leveraging community-reported data.
 *
 * Features:
 * - Async batch reporting (non-blocking)
 * - Local query caching
 * - Expiring domain queries
 * - Graceful degradation when backend unavailable
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportTakenDomains = reportTakenDomains;
exports.queryTakenDomains = queryTakenDomains;
exports.isKnownTaken = isKnownTaken;
exports.getExpiringDomains = getExpiringDomains;
exports.getCacheStats = getCacheStats;
exports.clearLocalCache = clearLocalCache;
const config_js_1 = require("../config.js");
const logger_js_1 = require("../utils/logger.js");
const concurrency_js_1 = require("../utils/concurrency.js");
const cache_js_1 = require("../utils/cache.js");
// ═══════════════════════════════════════════════════════════════════════════
// INTERNAL STATE
// ═══════════════════════════════════════════════════════════════════════════
/** Concurrency limiter for API requests */
const limiter = new concurrency_js_1.ConcurrencyLimiter(config_js_1.config.negativeCache.concurrency);
/** Local cache for query results (fqdn -> taken status) */
const localCache = new cache_js_1.TtlCache(config_js_1.config.negativeCache.localCacheTtl, 50000);
/** Pending reports to batch */
let pendingReports = [];
/** Debounce timer for batch reporting */
let reportTimer = null;
// ═══════════════════════════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Normalize base URL (remove trailing slashes).
 */
function normalizeBaseUrl(baseUrl) {
    if (!baseUrl)
        return null;
    return baseUrl.replace(/\/+$/, '');
}
/**
 * Build request headers with optional auth.
 */
function buildHeaders() {
    const headers = {
        'Content-Type': 'application/json',
    };
    if (config_js_1.config.negativeCache.token) {
        headers.Authorization = `Bearer ${config_js_1.config.negativeCache.token}`;
    }
    return headers;
}
/**
 * Fetch JSON with timeout.
 */
async function fetchJson(url, options) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), options.timeoutMs);
    try {
        const response = await fetch(url, {
            method: options.method,
            headers: buildHeaders(),
            body: options.body ? JSON.stringify(options.body) : undefined,
            signal: controller.signal,
        });
        const text = await response.text();
        let data = null;
        if (text) {
            try {
                data = JSON.parse(text);
            }
            catch {
                data = null;
            }
        }
        return { ok: response.ok, status: response.status, data };
    }
    catch (error) {
        if (error instanceof Error && error.name === 'AbortError') {
            logger_js_1.logger.debug('Negative cache request timed out', { url });
        }
        return { ok: false, status: 0, data: null };
    }
    finally {
        clearTimeout(timeout);
    }
}
// ═══════════════════════════════════════════════════════════════════════════
// REPORT FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Flush pending reports to backend.
 */
async function flushReports() {
    if (pendingReports.length === 0)
        return;
    const baseUrl = normalizeBaseUrl(config_js_1.config.negativeCache.baseUrl);
    if (!baseUrl)
        return;
    // Take current batch and clear pending
    const batch = pendingReports.splice(0, config_js_1.config.negativeCache.reportBatchSize);
    try {
        await limiter.run(async () => {
            const { ok, status } = await fetchJson(`${baseUrl}/report`, {
                method: 'POST',
                body: { domains: batch },
                timeoutMs: config_js_1.config.negativeCache.timeoutMs,
            });
            if (!ok) {
                logger_js_1.logger.debug('Negative cache report failed', { status, count: batch.length });
            }
            else {
                logger_js_1.logger.debug('Negative cache reported domains', { count: batch.length });
                // Update local cache with reported domains
                for (const report of batch) {
                    localCache.set(`taken:${report.fqdn.toLowerCase()}`, true);
                }
            }
        });
    }
    catch (error) {
        logger_js_1.logger.debug('Negative cache report error', {
            error: error instanceof Error ? error.message : String(error),
        });
    }
    // If more pending, schedule another flush
    if (pendingReports.length > 0) {
        scheduleFlush();
    }
}
/**
 * Schedule a debounced flush.
 */
function scheduleFlush() {
    if (reportTimer)
        return; // Already scheduled
    reportTimer = setTimeout(() => {
        reportTimer = null;
        flushReports().catch(() => {
            // Ignore errors - reporting is best-effort
        });
    }, config_js_1.config.negativeCache.reportDebounceMs);
}
/**
 * Report domains as taken (async, non-blocking).
 *
 * Batches reports and sends them periodically to reduce API calls.
 * This is fire-and-forget - errors are logged but not thrown.
 */
function reportTakenDomains(domains) {
    if (!config_js_1.config.negativeCache.enabled)
        return;
    // Add to pending queue
    pendingReports.push(...domains);
    // Immediately update local cache
    for (const domain of domains) {
        localCache.set(`taken:${domain.fqdn.toLowerCase()}`, true);
    }
    // Flush if batch is full, otherwise schedule debounced flush
    if (pendingReports.length >= config_js_1.config.negativeCache.reportBatchSize) {
        flushReports().catch(() => { });
    }
    else {
        scheduleFlush();
    }
}
// ═══════════════════════════════════════════════════════════════════════════
// QUERY FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Query the negative cache for known-taken domains.
 *
 * Returns a Set of FQDNs that are known to be taken.
 * Unknown domains should still be checked via normal availability APIs.
 */
async function queryTakenDomains(fqdns) {
    const taken = new Set();
    const toQuery = [];
    // Check local cache first
    for (const fqdn of fqdns) {
        const normalized = fqdn.toLowerCase();
        const cached = localCache.get(`taken:${normalized}`);
        if (cached === true) {
            taken.add(normalized);
        }
        else if (cached === undefined) {
            toQuery.push(normalized);
        }
        // If cached === false, it's known available (don't add to taken or query)
    }
    // If nothing to query or backend disabled, return local results
    if (toQuery.length === 0 || !config_js_1.config.negativeCache.enabled) {
        return {
            taken,
            unknown: toQuery,
            hitRate: fqdns.length > 0 ? taken.size / fqdns.length : 0,
        };
    }
    const baseUrl = normalizeBaseUrl(config_js_1.config.negativeCache.baseUrl);
    if (!baseUrl) {
        return { taken, unknown: toQuery, hitRate: taken.size / fqdns.length };
    }
    // Query backend for unknown domains
    try {
        const result = await limiter.run(async () => {
            const { ok, data } = await fetchJson(`${baseUrl}/query`, {
                method: 'POST',
                body: { domains: toQuery, include_expiry: false },
                timeoutMs: config_js_1.config.negativeCache.timeoutMs,
            });
            if (!ok || !data) {
                return null;
            }
            return data;
        });
        if (result) {
            // Update local cache and result set
            for (const item of result.taken) {
                const normalized = item.fqdn.toLowerCase();
                taken.add(normalized);
                localCache.set(`taken:${normalized}`, true);
            }
            // Cache misses as "not taken" (will expire and be rechecked)
            for (const fqdn of result.unknown) {
                localCache.set(`taken:${fqdn.toLowerCase()}`, false);
            }
            logger_js_1.logger.debug('Negative cache query result', {
                queried: toQuery.length,
                found_taken: result.taken.length,
                unknown: result.unknown.length,
            });
            return {
                taken,
                unknown: result.unknown,
                hitRate: taken.size / fqdns.length,
            };
        }
    }
    catch (error) {
        logger_js_1.logger.debug('Negative cache query error', {
            error: error instanceof Error ? error.message : String(error),
        });
    }
    // On error, return what we have from local cache
    return { taken, unknown: toQuery, hitRate: taken.size / fqdns.length };
}
/**
 * Check if a single domain is known to be taken.
 *
 * Fast path that only checks local cache.
 * Returns undefined if unknown (should check normally).
 */
function isKnownTaken(fqdn) {
    if (!config_js_1.config.negativeCache.enabled)
        return undefined;
    return localCache.get(`taken:${fqdn.toLowerCase()}`);
}
// ═══════════════════════════════════════════════════════════════════════════
// EXPIRING DOMAINS
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Get domains that are about to expire.
 */
async function getExpiringDomains(options = {}) {
    if (!config_js_1.config.negativeCache.enabled) {
        return { domains: [], total: 0 };
    }
    const baseUrl = normalizeBaseUrl(config_js_1.config.negativeCache.baseUrl);
    if (!baseUrl) {
        return { domains: [], total: 0 };
    }
    const { tlds, days = 30, limit = 25, keywords } = options;
    try {
        const queryParams = new URLSearchParams();
        if (tlds && tlds.length > 0)
            queryParams.set('tlds', tlds.join(','));
        queryParams.set('days', String(days));
        queryParams.set('limit', String(limit));
        if (keywords)
            queryParams.set('keywords', keywords);
        const result = await limiter.run(async () => {
            const { ok, data } = await fetchJson(`${baseUrl}/expiring?${queryParams.toString()}`, {
                method: 'GET',
                timeoutMs: config_js_1.config.negativeCache.timeoutMs,
            });
            if (!ok || !data) {
                return null;
            }
            return data;
        });
        if (result) {
            logger_js_1.logger.debug('Fetched expiring domains', {
                count: result.domains.length,
                total: result.total,
            });
            return result;
        }
    }
    catch (error) {
        logger_js_1.logger.debug('Failed to fetch expiring domains', {
            error: error instanceof Error ? error.message : String(error),
        });
    }
    return { domains: [], total: 0 };
}
// ═══════════════════════════════════════════════════════════════════════════
// CACHE MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Get local cache stats.
 */
function getCacheStats() {
    return {
        size: localCache.size,
        hitRate: 0, // Would need to track hits/misses
    };
}
/**
 * Clear local cache (for testing).
 */
function clearLocalCache() {
    localCache.clear();
}
//# sourceMappingURL=negative-cache.js.map