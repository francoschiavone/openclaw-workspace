"use strict";
/**
 * TTL-based In-Memory Cache.
 *
 * Simple but effective caching for domain availability and pricing.
 * Reduces API calls and improves response times.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.tldCache = exports.pricingCache = exports.domainCache = exports.TtlCache = void 0;
exports.domainCacheKey = domainCacheKey;
exports.tldCacheKey = tldCacheKey;
exports.getOrCompute = getOrCompute;
const config_js_1 = require("../config.js");
const logger_js_1 = require("./logger.js");
/**
 * Default maximum cache size to prevent memory exhaustion.
 * With ~1KB per entry average, 10000 entries â‰ˆ 10MB max.
 */
const DEFAULT_MAX_CACHE_SIZE = 10000;
/**
 * Generic TTL cache with automatic expiration and size limits.
 *
 * SECURITY: Implements max size to prevent memory DoS attacks.
 * When at capacity, evicts least-recently-used (LRU) entries.
 */
class TtlCache {
    cache = new Map();
    defaultTtlMs;
    maxSize;
    cleanupInterval = null;
    constructor(defaultTtlSeconds = 300, maxSize = DEFAULT_MAX_CACHE_SIZE) {
        this.defaultTtlMs = defaultTtlSeconds * 1000;
        this.maxSize = maxSize;
        // Clean up expired entries every minute
        // .unref() prevents this interval from keeping the process alive
        this.cleanupInterval = setInterval(() => this.cleanup(), 60000);
        this.cleanupInterval.unref();
    }
    /**
     * Get a value from cache if it exists and hasn't expired.
     * Moves entry to end of Map for O(1) LRU tracking via insertion order.
     */
    get(key) {
        const entry = this.cache.get(key);
        if (!entry) {
            return undefined;
        }
        const now = Date.now();
        // Check if expired
        if (now > entry.expiresAt) {
            this.cache.delete(key);
            return undefined;
        }
        // LRU optimization: Move to end of Map by re-inserting (O(1) operation)
        // This makes evictLRU() O(1) by using Map insertion order
        this.cache.delete(key);
        entry.lastAccessedAt = now;
        this.cache.set(key, entry);
        logger_js_1.logger.debug('Cache hit', { key, age_ms: now - entry.createdAt });
        return entry.value;
    }
    /**
     * Set a value in cache with optional custom TTL.
     * Implements LRU eviction when cache is at capacity.
     */
    set(key, value, ttlMs) {
        const now = Date.now();
        const expiresAt = now + (ttlMs ?? this.defaultTtlMs);
        // If key already exists, just update it
        if (this.cache.has(key)) {
            this.cache.set(key, {
                value,
                expiresAt,
                createdAt: now,
                lastAccessedAt: now,
            });
            return;
        }
        // If at capacity, evict least recently used entries
        // SECURITY: Use while loop to handle concurrent insertion race conditions
        while (this.cache.size >= this.maxSize) {
            this.evictLRU();
        }
        this.cache.set(key, {
            value,
            expiresAt,
            createdAt: now,
            lastAccessedAt: now,
        });
        logger_js_1.logger.debug('Cache set', {
            key,
            ttl_ms: expiresAt - now,
            size: this.cache.size,
        });
    }
    /**
     * Evict least recently used entry.
     * O(1) operation: Uses Map insertion order - first entry is oldest.
     */
    evictLRU() {
        // Map.keys().next() returns the first (oldest) key in O(1)
        const firstKey = this.cache.keys().next().value;
        if (firstKey !== undefined) {
            this.cache.delete(firstKey);
            logger_js_1.logger.debug('Cache LRU eviction', { evicted_key: firstKey });
        }
    }
    /**
     * Check if a key exists and is not expired.
     */
    has(key) {
        const value = this.get(key);
        return value !== undefined;
    }
    /**
     * Delete a specific key.
     */
    delete(key) {
        return this.cache.delete(key);
    }
    /**
     * Clear all cache entries.
     */
    clear() {
        this.cache.clear();
        logger_js_1.logger.debug('Cache cleared');
    }
    /**
     * Get the number of entries in cache.
     */
    get size() {
        return this.cache.size;
    }
    /**
     * Remove expired entries.
     */
    cleanup() {
        const now = Date.now();
        let removed = 0;
        for (const [key, entry] of this.cache) {
            if (now > entry.expiresAt) {
                this.cache.delete(key);
                removed++;
            }
        }
        if (removed > 0) {
            logger_js_1.logger.debug('Cache cleanup', { removed, remaining: this.cache.size });
        }
    }
    /**
     * Stop the cleanup interval (for testing/shutdown).
     */
    destroy() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
        this.cache.clear();
    }
}
exports.TtlCache = TtlCache;
/**
 * Generate a cache key for domain availability.
 */
function domainCacheKey(domain, source) {
    return `domain:${domain.toLowerCase()}:${source}`;
}
/**
 * Generate a cache key for TLD info.
 */
function tldCacheKey(tld) {
    return `tld:${tld.toLowerCase()}`;
}
/**
 * Global cache instances.
 */
exports.domainCache = new TtlCache(config_js_1.config.cache.availabilityTtl);
exports.pricingCache = new TtlCache(config_js_1.config.cache.pricingTtl);
exports.tldCache = new TtlCache(86400); // 24 hours for TLD info
/**
 * Get or compute a domain result.
 */
async function getOrCompute(cache, key, compute, ttlMs) {
    const cached = cache.get(key);
    if (cached !== undefined) {
        return { value: cached, fromCache: true };
    }
    const value = await compute();
    cache.set(key, value, ttlMs);
    return { value, fromCache: false };
}
//# sourceMappingURL=cache.js.map