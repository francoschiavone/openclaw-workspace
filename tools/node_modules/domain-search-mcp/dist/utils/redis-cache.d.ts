/**
 * Hybrid Redis + In-Memory Cache.
 *
 * Uses Redis as primary cache when available, with automatic fallback
 * to in-memory cache when Redis is unavailable or not configured.
 *
 * Features:
 * - Zero-config: Works without Redis (uses in-memory only)
 * - Graceful degradation: Falls back to in-memory on Redis failures
 * - Circuit breaker: Prevents hammering failing Redis
 * - Automatic reconnection: Reconnects when Redis comes back
 * - Shared cache: Multiple MCP instances share the same Redis cache
 */
export interface RedisCacheOptions {
    /** Redis connection URL (redis://[:password@]host:port) */
    redisUrl?: string;
    /** Key prefix for namespacing */
    keyPrefix?: string;
    /** Default TTL in seconds */
    defaultTtlSeconds?: number;
    /** Max entries for in-memory fallback cache */
    fallbackMaxEntries?: number;
    /** Connection timeout in ms */
    connectTimeoutMs?: number;
    /** Command timeout in ms */
    commandTimeoutMs?: number;
}
export declare class HybridCache<T> {
    private readonly keyPrefix;
    private readonly defaultTtlSeconds;
    private readonly commandTimeoutMs;
    private redis;
    private readonly fallbackCache;
    private readonly circuitBreaker;
    private isConnected;
    private readonly redisUrl;
    constructor(options?: RedisCacheOptions);
    /**
     * Initialize Redis connection.
     */
    private initRedis;
    /**
     * Mask password in Redis URL for logging.
     */
    private maskUrl;
    /**
     * Build full key with prefix.
     */
    private buildKey;
    /**
     * Get value from cache.
     */
    get(key: string): Promise<T | undefined>;
    /**
     * Set value in cache.
     */
    set(key: string, value: T, ttlSeconds?: number): Promise<void>;
    /**
     * Delete value from cache.
     */
    delete(key: string): Promise<void>;
    /**
     * Check if key exists.
     */
    has(key: string): Promise<boolean>;
    /**
     * Get cache stats.
     */
    getStats(): {
        redisConnected: boolean;
        redisConfigured: boolean;
        fallbackSize: number;
        circuitState: string;
    };
    /**
     * Close Redis connection.
     */
    close(): Promise<void>;
}
/**
 * Get the default hybrid cache instance.
 * Uses REDIS_URL environment variable if set.
 */
export declare function getDefaultHybridCache(): HybridCache<unknown>;
/**
 * Create a namespaced hybrid cache.
 */
export declare function createHybridCache<T>(namespace: string, options?: Partial<RedisCacheOptions>): HybridCache<T>;
//# sourceMappingURL=redis-cache.d.ts.map