/**
 * Adaptive Concurrency Limiter.
 *
 * Dynamically adjusts concurrency based on real-time performance metrics.
 * Unlike circuit breaker (which blocks traffic), this maintains flow but
 * adjusts intensity based on success/error rates and latency.
 *
 * Behavior:
 * - Starts at minConcurrency
 * - Increases towards maxConcurrency when error rate is low
 * - Decreases when errors or timeouts spike
 * - Uses AIMD (Additive Increase, Multiplicative Decrease) algorithm
 */
export interface AdaptiveConcurrencyOptions {
    /** Name for logging and metrics */
    name: string;
    /** Minimum concurrency limit (floor) */
    minConcurrency?: number;
    /** Maximum concurrency limit (ceiling) */
    maxConcurrency?: number;
    /** Starting concurrency */
    initialConcurrency?: number;
    /** Error rate threshold to trigger decrease (0-1) */
    errorThreshold?: number;
    /** Latency threshold (ms) to trigger decrease */
    latencyThresholdMs?: number;
    /** Window size in ms for calculating metrics */
    windowMs?: number;
    /** Minimum samples before adjusting */
    minSamples?: number;
    /** How often to evaluate and adjust (ms) */
    evaluationIntervalMs?: number;
}
export declare class AdaptiveConcurrencyLimiter {
    private readonly name;
    private readonly minConcurrency;
    private readonly maxConcurrency;
    private readonly errorThreshold;
    private readonly latencyThresholdMs;
    private readonly windowMs;
    private readonly minSamples;
    private readonly evaluationIntervalMs;
    private currentConcurrency;
    private active;
    private queue;
    private samples;
    private evaluationTimer;
    private lastAdjustment;
    constructor(options: AdaptiveConcurrencyOptions);
    /**
     * Execute a function with adaptive concurrency limiting.
     */
    run<T>(fn: () => Promise<T>): Promise<T>;
    /**
     * Get current state (for monitoring).
     */
    getState(): {
        name: string;
        currentConcurrency: number;
        minConcurrency: number;
        maxConcurrency: number;
        activeRequests: number;
        queuedRequests: number;
        recentErrorRate: number;
        recentAvgLatency: number;
        sampleCount: number;
    };
    /**
     * Stop the evaluation timer (for cleanup).
     */
    stop(): void;
    private acquire;
    private release;
    private recordSample;
    private pruneOldSamples;
    private calculateMetrics;
    private startEvaluation;
    private evaluate;
}
/**
 * Get or create an adaptive concurrency limiter by name.
 */
export declare function getAdaptiveLimiter(options: AdaptiveConcurrencyOptions): AdaptiveConcurrencyLimiter;
/**
 * Get all adaptive limiter states (for /metrics endpoint).
 */
export declare function getAllAdaptiveStates(): Array<ReturnType<AdaptiveConcurrencyLimiter['getState']>>;
/**
 * Stop all adaptive limiters (for cleanup/testing).
 */
export declare function stopAllAdaptiveLimiters(): void;
//# sourceMappingURL=adaptive-concurrency.d.ts.map