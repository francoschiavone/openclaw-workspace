/**
 * Concurrency limiters for async work.
 *
 * Keeps upstream services from being flooded and helps control latency.
 */
export declare class ConcurrencyLimiter {
    private readonly limit;
    private active;
    private queue;
    constructor(limit: number);
    run<T>(fn: () => Promise<T>): Promise<T>;
    private acquire;
    private release;
}
export declare class KeyedLimiter {
    private readonly limit;
    private readonly limiters;
    constructor(limit: number);
    run<T>(key: string, fn: () => Promise<T>): Promise<T>;
}
//# sourceMappingURL=concurrency.d.ts.map