"use strict";
/**
 * Hybrid Redis + In-Memory Cache.
 *
 * Uses Redis as primary cache when available, with automatic fallback
 * to in-memory cache when Redis is unavailable or not configured.
 *
 * Features:
 * - Zero-config: Works without Redis (uses in-memory only)
 * - Graceful degradation: Falls back to in-memory on Redis failures
 * - Circuit breaker: Prevents hammering failing Redis
 * - Automatic reconnection: Reconnects when Redis comes back
 * - Shared cache: Multiple MCP instances share the same Redis cache
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HybridCache = void 0;
exports.getDefaultHybridCache = getDefaultHybridCache;
exports.createHybridCache = createHybridCache;
const ioredis_1 = __importDefault(require("ioredis"));
const logger_js_1 = require("./logger.js");
const cache_js_1 = require("./cache.js");
const circuit_breaker_js_1 = require("./circuit-breaker.js");
const metrics_js_1 = require("./metrics.js");
const DEFAULT_OPTIONS = {
    keyPrefix: 'dsmcp:',
    defaultTtlSeconds: 3600,
    fallbackMaxEntries: 10000,
    connectTimeoutMs: 5000,
    commandTimeoutMs: 1000,
};
// ═══════════════════════════════════════════════════════════════════════════
// Redis Cache Class
// ═══════════════════════════════════════════════════════════════════════════
class HybridCache {
    keyPrefix;
    defaultTtlSeconds;
    commandTimeoutMs;
    redis = null;
    fallbackCache;
    circuitBreaker;
    isConnected = false;
    redisUrl;
    constructor(options = {}) {
        this.keyPrefix = options.keyPrefix ?? DEFAULT_OPTIONS.keyPrefix;
        this.defaultTtlSeconds = options.defaultTtlSeconds ?? DEFAULT_OPTIONS.defaultTtlSeconds;
        this.commandTimeoutMs = options.commandTimeoutMs ?? DEFAULT_OPTIONS.commandTimeoutMs;
        this.redisUrl = options.redisUrl;
        // In-memory fallback cache
        this.fallbackCache = new cache_js_1.TtlCache(this.defaultTtlSeconds, options.fallbackMaxEntries ?? DEFAULT_OPTIONS.fallbackMaxEntries);
        // Circuit breaker for Redis operations
        this.circuitBreaker = new circuit_breaker_js_1.CircuitBreaker({
            name: 'redis_cache',
            failureThreshold: 3,
            resetTimeoutMs: 30_000,
            failureWindowMs: 60_000,
            successThreshold: 2,
        });
        // Connect to Redis if URL provided
        if (options.redisUrl) {
            this.initRedis(options.redisUrl, options.connectTimeoutMs ?? DEFAULT_OPTIONS.connectTimeoutMs);
        }
        else {
            logger_js_1.logger.info('Redis not configured, using in-memory cache only');
        }
    }
    /**
     * Initialize Redis connection.
     */
    initRedis(url, connectTimeoutMs) {
        try {
            this.redis = new ioredis_1.default(url, {
                connectTimeout: connectTimeoutMs,
                maxRetriesPerRequest: 1,
                retryStrategy: (times) => {
                    if (times > 3) {
                        logger_js_1.logger.warn('Redis connection failed, using fallback cache', { attempts: times });
                        return null; // Stop retrying
                    }
                    return Math.min(times * 500, 2000); // Exponential backoff
                },
                lazyConnect: false,
            });
            this.redis.on('connect', () => {
                this.isConnected = true;
                logger_js_1.logger.info('Redis connected', { url: this.maskUrl(url) });
                (0, metrics_js_1.incrementCounter)('redis_connected');
            });
            this.redis.on('error', (err) => {
                logger_js_1.logger.debug('Redis error', { error: err.message });
                (0, metrics_js_1.incrementCounter)('redis_error');
            });
            this.redis.on('close', () => {
                this.isConnected = false;
                logger_js_1.logger.debug('Redis connection closed');
                (0, metrics_js_1.incrementCounter)('redis_disconnected');
            });
            this.redis.on('reconnecting', () => {
                logger_js_1.logger.debug('Redis reconnecting...');
                (0, metrics_js_1.incrementCounter)('redis_reconnecting');
            });
        }
        catch (error) {
            logger_js_1.logger.warn('Failed to initialize Redis', {
                error: error instanceof Error ? error.message : 'Unknown error',
            });
            this.redis = null;
        }
    }
    /**
     * Mask password in Redis URL for logging.
     */
    maskUrl(url) {
        return url.replace(/:([^@]+)@/, ':***@');
    }
    /**
     * Build full key with prefix.
     */
    buildKey(key) {
        return `${this.keyPrefix}${key}`;
    }
    /**
     * Get value from cache.
     */
    async get(key) {
        const fullKey = this.buildKey(key);
        // Try Redis first if available
        if (this.redis && this.isConnected) {
            try {
                const startTime = Date.now();
                const value = await this.circuitBreaker.execute(async () => {
                    return Promise.race([
                        this.redis.get(fullKey),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Redis timeout')), this.commandTimeoutMs)),
                    ]);
                });
                (0, metrics_js_1.recordLatency)('redis_get_latency', Date.now() - startTime);
                if (value !== null) {
                    (0, metrics_js_1.incrementCounter)('redis_cache_hit');
                    return JSON.parse(value);
                }
                (0, metrics_js_1.incrementCounter)('redis_cache_miss');
                // Fall through to fallback cache
            }
            catch (error) {
                if (error instanceof circuit_breaker_js_1.CircuitOpenError) {
                    (0, metrics_js_1.incrementCounter)('redis_circuit_open');
                }
                else {
                    (0, metrics_js_1.incrementCounter)('redis_get_error');
                    logger_js_1.logger.debug('Redis get failed, using fallback', {
                        key,
                        error: error instanceof Error ? error.message : 'Unknown',
                    });
                }
                // Fall through to fallback cache
            }
        }
        // Use fallback cache
        return this.fallbackCache.get(key);
    }
    /**
     * Set value in cache.
     */
    async set(key, value, ttlSeconds) {
        const fullKey = this.buildKey(key);
        const ttl = ttlSeconds ?? this.defaultTtlSeconds;
        const serialized = JSON.stringify(value);
        // Always set in fallback cache
        this.fallbackCache.set(key, value, ttl);
        // Try Redis if available
        if (this.redis && this.isConnected) {
            try {
                const startTime = Date.now();
                await this.circuitBreaker.execute(async () => {
                    return Promise.race([
                        this.redis.setex(fullKey, ttl, serialized),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Redis timeout')), this.commandTimeoutMs)),
                    ]);
                });
                (0, metrics_js_1.recordLatency)('redis_set_latency', Date.now() - startTime);
                (0, metrics_js_1.incrementCounter)('redis_set_success');
            }
            catch (error) {
                if (error instanceof circuit_breaker_js_1.CircuitOpenError) {
                    (0, metrics_js_1.incrementCounter)('redis_circuit_open');
                }
                else {
                    (0, metrics_js_1.incrementCounter)('redis_set_error');
                    logger_js_1.logger.debug('Redis set failed', {
                        key,
                        error: error instanceof Error ? error.message : 'Unknown',
                    });
                }
                // Value is already in fallback cache, so we're fine
            }
        }
    }
    /**
     * Delete value from cache.
     */
    async delete(key) {
        const fullKey = this.buildKey(key);
        // Delete from fallback
        this.fallbackCache.delete(key);
        // Try Redis if available
        if (this.redis && this.isConnected) {
            try {
                await this.circuitBreaker.execute(async () => {
                    return this.redis.del(fullKey);
                });
                (0, metrics_js_1.incrementCounter)('redis_delete_success');
            }
            catch (error) {
                (0, metrics_js_1.incrementCounter)('redis_delete_error');
                // Ignore errors - key might not exist
            }
        }
    }
    /**
     * Check if key exists.
     */
    async has(key) {
        const value = await this.get(key);
        return value !== undefined;
    }
    /**
     * Get cache stats.
     */
    getStats() {
        return {
            redisConnected: this.isConnected,
            redisConfigured: !!this.redisUrl,
            fallbackSize: this.fallbackCache.size,
            circuitState: this.circuitBreaker.getState().state,
        };
    }
    /**
     * Close Redis connection.
     */
    async close() {
        if (this.redis) {
            await this.redis.quit();
            this.redis = null;
            this.isConnected = false;
        }
    }
}
exports.HybridCache = HybridCache;
// ═══════════════════════════════════════════════════════════════════════════
// Singleton Instance
// ═══════════════════════════════════════════════════════════════════════════
let defaultCache = null;
/**
 * Get the default hybrid cache instance.
 * Uses REDIS_URL environment variable if set.
 */
function getDefaultHybridCache() {
    if (!defaultCache) {
        defaultCache = new HybridCache({
            redisUrl: process.env.REDIS_URL,
            keyPrefix: 'dsmcp:',
            defaultTtlSeconds: 3600,
        });
    }
    return defaultCache;
}
/**
 * Create a namespaced hybrid cache.
 */
function createHybridCache(namespace, options = {}) {
    return new HybridCache({
        redisUrl: process.env.REDIS_URL,
        keyPrefix: `dsmcp:${namespace}:`,
        ...options,
    });
}
//# sourceMappingURL=redis-cache.js.map