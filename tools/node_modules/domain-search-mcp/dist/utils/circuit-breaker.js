"use strict";
/**
 * Circuit Breaker Pattern Implementation.
 *
 * Prevents cascading failures by temporarily blocking requests to failing services.
 * After a cooldown period, allows a probe request to test if service recovered.
 *
 * States:
 * - CLOSED: Normal operation, requests pass through
 * - OPEN: Service failing, requests blocked immediately
 * - HALF_OPEN: Testing recovery, single request allowed
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CircuitBreaker = exports.CircuitOpenError = void 0;
exports.getCircuitBreaker = getCircuitBreaker;
exports.getAllCircuitStates = getAllCircuitStates;
exports.resetAllCircuitBreakers = resetAllCircuitBreakers;
const logger_js_1 = require("./logger.js");
const metrics_js_1 = require("./metrics.js");
const DEFAULT_OPTIONS = {
    failureThreshold: 5,
    resetTimeoutMs: 30_000, // 30 seconds
    failureWindowMs: 60_000, // 1 minute
    successThreshold: 2,
};
// ═══════════════════════════════════════════════════════════════════════════
// Circuit Breaker Error
// ═══════════════════════════════════════════════════════════════════════════
class CircuitOpenError extends Error {
    circuitName;
    openedAt;
    resetAt;
    constructor(name, openedAt, resetTimeoutMs) {
        const resetAt = openedAt + resetTimeoutMs;
        const remainingMs = Math.max(0, resetAt - Date.now());
        super(`Circuit breaker '${name}' is OPEN. Retry in ${Math.ceil(remainingMs / 1000)}s`);
        this.name = 'CircuitOpenError';
        this.circuitName = name;
        this.openedAt = openedAt;
        this.resetAt = resetAt;
    }
}
exports.CircuitOpenError = CircuitOpenError;
// ═══════════════════════════════════════════════════════════════════════════
// Circuit Breaker Class
// ═══════════════════════════════════════════════════════════════════════════
class CircuitBreaker {
    name;
    failureThreshold;
    resetTimeoutMs;
    failureWindowMs;
    successThreshold;
    state = 'closed';
    failures = [];
    lastFailureTime = 0;
    halfOpenSuccesses = 0;
    openedAt = 0;
    constructor(options) {
        this.name = options.name;
        this.failureThreshold = options.failureThreshold ?? DEFAULT_OPTIONS.failureThreshold;
        this.resetTimeoutMs = options.resetTimeoutMs ?? DEFAULT_OPTIONS.resetTimeoutMs;
        this.failureWindowMs = options.failureWindowMs ?? DEFAULT_OPTIONS.failureWindowMs;
        this.successThreshold = options.successThreshold ?? DEFAULT_OPTIONS.successThreshold;
    }
    /**
     * Execute a function with circuit breaker protection.
     *
     * @throws CircuitOpenError if circuit is open
     * @throws Original error if function fails and circuit stays closed
     */
    async execute(fn) {
        // Check if we should block
        if (this.state === 'open') {
            if (this.shouldAttemptReset()) {
                this.transitionTo('half_open');
            }
            else {
                (0, metrics_js_1.incrementCounter)(`circuit_${this.name}_rejected`);
                throw new CircuitOpenError(this.name, this.openedAt, this.resetTimeoutMs);
            }
        }
        const startTime = Date.now();
        try {
            const result = await fn();
            this.onSuccess(Date.now() - startTime);
            return result;
        }
        catch (error) {
            this.onFailure(error);
            throw error;
        }
    }
    /**
     * Check if circuit should transition from open to half-open.
     */
    shouldAttemptReset() {
        return Date.now() >= this.openedAt + this.resetTimeoutMs;
    }
    /**
     * Handle successful execution.
     */
    onSuccess(latencyMs) {
        (0, metrics_js_1.recordLatency)(`circuit_${this.name}_latency`, latencyMs);
        (0, metrics_js_1.incrementCounter)(`circuit_${this.name}_success`);
        if (this.state === 'half_open') {
            this.halfOpenSuccesses++;
            if (this.halfOpenSuccesses >= this.successThreshold) {
                this.transitionTo('closed');
                logger_js_1.logger.info('Circuit breaker recovered', {
                    name: this.name,
                    state: 'closed',
                    successCount: this.halfOpenSuccesses,
                });
            }
        }
        else if (this.state === 'closed') {
            // Clear old failures on success
            this.pruneOldFailures();
        }
    }
    /**
     * Handle failed execution.
     */
    onFailure(error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        (0, metrics_js_1.incrementCounter)(`circuit_${this.name}_failure`);
        if (this.state === 'half_open') {
            // Any failure in half-open goes back to open
            this.transitionTo('open');
            logger_js_1.logger.warn('Circuit breaker reopened (half-open failure)', {
                name: this.name,
                error: errorMessage,
            });
            return;
        }
        // Record failure
        this.failures.push({
            timestamp: Date.now(),
            error: errorMessage,
        });
        this.lastFailureTime = Date.now();
        // Prune old failures outside window
        this.pruneOldFailures();
        // Check if threshold exceeded
        if (this.failures.length >= this.failureThreshold) {
            this.transitionTo('open');
            logger_js_1.logger.warn('Circuit breaker opened', {
                name: this.name,
                failures: this.failures.length,
                threshold: this.failureThreshold,
                recentErrors: this.failures.slice(-3).map(f => f.error),
            });
        }
    }
    /**
     * Transition to a new state.
     */
    transitionTo(newState) {
        const oldState = this.state;
        this.state = newState;
        if (newState === 'open') {
            this.openedAt = Date.now();
            this.halfOpenSuccesses = 0;
            (0, metrics_js_1.incrementCounter)(`circuit_${this.name}_opened`);
        }
        else if (newState === 'closed') {
            this.failures = [];
            this.halfOpenSuccesses = 0;
            (0, metrics_js_1.incrementCounter)(`circuit_${this.name}_closed`);
        }
        else if (newState === 'half_open') {
            this.halfOpenSuccesses = 0;
            (0, metrics_js_1.incrementCounter)(`circuit_${this.name}_half_open`);
        }
        logger_js_1.logger.debug('Circuit breaker state change', {
            name: this.name,
            from: oldState,
            to: newState,
        });
    }
    /**
     * Remove failures outside the time window.
     */
    pruneOldFailures() {
        const cutoff = Date.now() - this.failureWindowMs;
        this.failures = this.failures.filter(f => f.timestamp > cutoff);
    }
    /**
     * Get current circuit state (for monitoring).
     */
    getState() {
        return {
            name: this.name,
            state: this.state,
            failures: this.failures.length,
            lastFailure: this.lastFailureTime || null,
            openedAt: this.state === 'open' ? this.openedAt : null,
        };
    }
    /**
     * Manually reset the circuit (for testing/admin).
     */
    reset() {
        this.state = 'closed';
        this.failures = [];
        this.halfOpenSuccesses = 0;
        this.openedAt = 0;
        logger_js_1.logger.info('Circuit breaker manually reset', { name: this.name });
    }
    /**
     * Check if circuit is currently allowing requests.
     */
    isAllowingRequests() {
        if (this.state === 'closed')
            return true;
        if (this.state === 'half_open')
            return true;
        if (this.state === 'open' && this.shouldAttemptReset())
            return true;
        return false;
    }
}
exports.CircuitBreaker = CircuitBreaker;
// ═══════════════════════════════════════════════════════════════════════════
// Circuit Breaker Registry
// ═══════════════════════════════════════════════════════════════════════════
const circuitBreakers = new Map();
/**
 * Get or create a circuit breaker by name.
 */
function getCircuitBreaker(options) {
    let breaker = circuitBreakers.get(options.name);
    if (!breaker) {
        breaker = new CircuitBreaker(options);
        circuitBreakers.set(options.name, breaker);
    }
    return breaker;
}
/**
 * Get all circuit breaker states (for /metrics endpoint).
 */
function getAllCircuitStates() {
    return Array.from(circuitBreakers.values()).map(cb => cb.getState());
}
/**
 * Reset all circuit breakers (for testing).
 */
function resetAllCircuitBreakers() {
    for (const breaker of circuitBreakers.values()) {
        breaker.reset();
    }
}
//# sourceMappingURL=circuit-breaker.js.map