/**
 * Simple in-memory rate limiter for MCP tool calls.
 *
 * P3 FIX: Prevents rapid-fire requests that could abuse external APIs.
 * Uses sliding window algorithm for smooth rate limiting.
 */
export declare class RateLimiter {
    private readonly windowMs;
    private readonly maxRequests;
    private readonly requests;
    /**
     * Create a new rate limiter.
     *
     * @param maxRequests - Maximum requests allowed per window
     * @param windowMs - Time window in milliseconds (default: 60000 = 1 minute)
     */
    constructor(maxRequests: number, windowMs?: number);
    /**
     * Check if a request is allowed for the given key.
     * If allowed, records the request.
     *
     * @param key - Identifier for the rate limit bucket (e.g., 'suggest_domains')
     * @returns true if request is allowed, false if rate limited
     */
    tryRequest(key: string): boolean;
    /**
     * Get remaining requests for a key.
     */
    getRemaining(key: string): number;
    /**
     * Get time until the rate limit resets (in ms).
     */
    getResetTime(key: string): number;
    /**
     * Clear all rate limit data (for testing).
     */
    clear(): void;
}
/**
 * Global rate limiter for AI inference calls.
 * Limits to 30 AI requests per minute to protect VPS.
 */
export declare const inferenceRateLimiter: RateLimiter;
/**
 * Global rate limiter for domain search calls.
 * More generous: 120 requests per minute.
 */
export declare const searchRateLimiter: RateLimiter;
/**
 * Check rate limit and throw if exceeded.
 */
export declare function checkRateLimit(limiter: RateLimiter, key: string, operationName: string): void;
//# sourceMappingURL=rate-limiter.d.ts.map