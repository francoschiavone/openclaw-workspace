/**
 * Lightweight in-memory metrics collection.
 *
 * Tracks latencies (with percentile calculation), counters, and hit rates.
 * Designed for the /metrics endpoint and observability.
 *
 * Memory-bounded: Uses sliding window for histograms to prevent unbounded growth.
 */
interface HistogramSummary {
    count: number;
    min: number;
    max: number;
    avg: number;
    p50: number;
    p90: number;
    p95: number;
    p99: number;
}
interface MetricsSummary {
    uptime_seconds: number;
    collected_at: string;
    histograms: Record<string, HistogramSummary>;
    counters: Record<string, number>;
    hit_rates: Record<string, {
        hits: number;
        misses: number;
        rate: number;
    }>;
}
/**
 * Record a latency value in milliseconds.
 *
 * @example
 * const start = Date.now();
 * await doWork();
 * recordLatency('rdap_lookup', Date.now() - start);
 */
export declare function recordLatency(name: string, ms: number): void;
/**
 * Increment a counter.
 *
 * @example
 * incrementCounter('rdap_requests');
 * incrementCounter('rdap_errors');
 */
export declare function incrementCounter(name: string, amount?: number): void;
/**
 * Get current counter value.
 */
export declare function getCounter(name: string): number;
/**
 * Record a cache hit.
 *
 * @example
 * if (cache.has(key)) {
 *   recordCacheHit('domain_cache');
 *   return cache.get(key);
 * }
 * recordCacheMiss('domain_cache');
 */
export declare function recordCacheHit(name: string): void;
/**
 * Record a cache miss.
 */
export declare function recordCacheMiss(name: string): void;
/**
 * Get hit rate as percentage (0-100).
 */
export declare function getHitRate(name: string): number;
/**
 * Get complete metrics summary for /metrics endpoint.
 *
 * Returns all collected metrics with percentiles and hit rates calculated.
 */
export declare function getMetricsSummary(): MetricsSummary;
/**
 * Reset all metrics (for testing).
 */
export declare function resetMetrics(): void;
/**
 * Timer helper for measuring async operation latency.
 *
 * @example
 * const stop = startTimer('api_call');
 * try {
 *   await apiCall();
 * } finally {
 *   stop(); // Records latency automatically
 * }
 */
export declare function startTimer(metricName: string): () => number;
/**
 * Wrap an async function with automatic latency recording.
 *
 * @example
 * const timedFetch = withLatency('fetch_data', fetchData);
 * await timedFetch(url);
 */
export declare function withLatency<T extends (...args: unknown[]) => Promise<unknown>>(metricName: string, fn: T): T;
export {};
//# sourceMappingURL=metrics.d.ts.map