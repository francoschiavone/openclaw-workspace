"use strict";
/**
 * Custom Error Classes for Domain Search MCP.
 *
 * These errors are designed to be:
 * 1. User-friendly (clear messages for non-developers)
 * 2. Actionable (suggest what to do next)
 * 3. Informative (include context for debugging)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationError = exports.TimeoutError = exports.NoSourceAvailableError = exports.AuthenticationError = exports.RegistrarApiError = exports.RateLimitError = exports.UnsupportedTldError = exports.InvalidDomainError = exports.DomainSearchError = void 0;
exports.wrapError = wrapError;
/**
 * Base error class for all domain search errors.
 */
class DomainSearchError extends Error {
    /** Machine-readable error code */
    code;
    /** User-friendly message */
    userMessage;
    /** Can this operation be retried? */
    retryable;
    /** Suggested action for the user */
    suggestedAction;
    constructor(code, message, userMessage, options) {
        super(message);
        this.name = 'DomainSearchError';
        this.code = code;
        this.userMessage = userMessage;
        this.retryable = options?.retryable ?? false;
        this.suggestedAction = options?.suggestedAction;
        if (options?.cause) {
            this.cause = options.cause;
        }
    }
    /**
     * Convert to a plain object for JSON responses.
     */
    toJSON() {
        return {
            code: this.code,
            message: this.userMessage,
            retryable: this.retryable,
            suggestedAction: this.suggestedAction,
        };
    }
}
exports.DomainSearchError = DomainSearchError;
/**
 * Error when a domain name is invalid.
 */
class InvalidDomainError extends DomainSearchError {
    constructor(domain, reason) {
        super('INVALID_DOMAIN', `Invalid domain: ${domain} - ${reason}`, `The domain "${domain}" is not valid: ${reason}`, {
            retryable: false,
            suggestedAction: 'Check the domain name for typos or invalid characters.',
        });
        this.name = 'InvalidDomainError';
    }
}
exports.InvalidDomainError = InvalidDomainError;
/**
 * Error when a TLD is not supported.
 */
class UnsupportedTldError extends DomainSearchError {
    constructor(tld, availableTlds) {
        const suggestion = availableTlds.length > 0
            ? `Try one of these: ${availableTlds.slice(0, 5).join(', ')}`
            : 'Contact support for TLD availability.';
        super('UNSUPPORTED_TLD', `TLD not supported: .${tld}`, `The TLD ".${tld}" is not supported for searching.`, {
            retryable: false,
            suggestedAction: suggestion,
        });
        this.name = 'UnsupportedTldError';
    }
}
exports.UnsupportedTldError = UnsupportedTldError;
/**
 * Error when an API rate limit is hit.
 */
class RateLimitError extends DomainSearchError {
    /** When to retry (Unix timestamp) */
    retryAfter;
    constructor(registrar, retryAfterSeconds) {
        super('RATE_LIMIT', `Rate limit hit for ${registrar}`, `Too many requests to ${registrar}. Please slow down.`, {
            retryable: true,
            suggestedAction: retryAfterSeconds
                ? `Wait ${retryAfterSeconds} seconds before trying again.`
                : 'Wait a moment and try again, or check fewer domains at once.',
        });
        this.name = 'RateLimitError';
        if (retryAfterSeconds) {
            this.retryAfter = Date.now() + retryAfterSeconds * 1000;
        }
    }
}
exports.RateLimitError = RateLimitError;
/**
 * Error when a registrar API fails.
 */
class RegistrarApiError extends DomainSearchError {
    /** HTTP status code if available */
    statusCode;
    constructor(registrar, message, statusCode, cause) {
        const isServerError = statusCode !== undefined && statusCode >= 500;
        super('REGISTRAR_API_ERROR', `${registrar} API error: ${message}`, isServerError
            ? `${registrar} is experiencing issues. We'll try another source.`
            : `Could not check with ${registrar}: ${message}`, {
            retryable: isServerError,
            suggestedAction: isServerError
                ? 'The system will automatically try alternative sources.'
                : `Check your ${registrar} API configuration.`,
            cause,
        });
        this.name = 'RegistrarApiError';
        this.statusCode = statusCode;
    }
}
exports.RegistrarApiError = RegistrarApiError;
/**
 * Error when API credentials are missing or invalid.
 */
class AuthenticationError extends DomainSearchError {
    constructor(registrar, reason) {
        super('AUTH_ERROR', `Authentication failed for ${registrar}: ${reason || 'Invalid credentials'}`, `Could not authenticate with ${registrar}.`, {
            retryable: false,
            suggestedAction: `Check your ${registrar.toUpperCase()}_API_KEY and ${registrar.toUpperCase()}_API_SECRET in your .env file.`,
        });
        this.name = 'AuthenticationError';
    }
}
exports.AuthenticationError = AuthenticationError;
/**
 * Error when no data source is available.
 */
class NoSourceAvailableError extends DomainSearchError {
    constructor(domain, triedSources) {
        super('NO_SOURCE_AVAILABLE', `No source available for ${domain}. Tried: ${triedSources.join(', ')}`, `Could not check availability for "${domain}". All sources failed.`, {
            retryable: true,
            suggestedAction: 'Try again in a few minutes, or check the domain manually at a registrar website.',
        });
        this.name = 'NoSourceAvailableError';
    }
}
exports.NoSourceAvailableError = NoSourceAvailableError;
/**
 * Error when a network request times out.
 */
class TimeoutError extends DomainSearchError {
    constructor(operation, timeoutMs) {
        super('TIMEOUT', `Operation timed out: ${operation} (${timeoutMs}ms)`, `The request took too long to complete.`, {
            retryable: true,
            suggestedAction: 'Try again - this might be a temporary network issue.',
        });
        this.name = 'TimeoutError';
    }
}
exports.TimeoutError = TimeoutError;
/**
 * Error when a required configuration is missing.
 */
class ConfigurationError extends DomainSearchError {
    constructor(missing, howToFix) {
        super('CONFIG_ERROR', `Missing configuration: ${missing}`, `Server configuration is incomplete.`, {
            retryable: false,
            suggestedAction: howToFix,
        });
        this.name = 'ConfigurationError';
    }
}
exports.ConfigurationError = ConfigurationError;
/**
 * Convert any error to a DomainSearchError.
 */
function wrapError(error) {
    if (error instanceof DomainSearchError) {
        return error;
    }
    if (error instanceof Error) {
        return new DomainSearchError('UNKNOWN_ERROR', error.message, 'An unexpected error occurred.', {
            retryable: true,
            suggestedAction: 'Try again or contact support if the issue persists.',
            cause: error,
        });
    }
    return new DomainSearchError('UNKNOWN_ERROR', String(error), 'An unexpected error occurred.', {
        retryable: true,
        suggestedAction: 'Try again or contact support if the issue persists.',
    });
}
//# sourceMappingURL=errors.js.map