"use strict";
/**
 * Structured JSON Logger with Secret Masking.
 *
 * - Outputs JSON for easy parsing
 * - Masks API keys and secrets automatically
 * - Includes request IDs for tracing
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.logger = void 0;
exports.generateRequestId = generateRequestId;
exports.setRequestId = setRequestId;
exports.clearRequestId = clearRequestId;
const config_js_1 = require("../config.js");
/**
 * Patterns that look like API keys or secrets.
 * These will be masked in log output.
 */
const SECRET_PATTERNS = [
    // P2 FIX: Bearer tokens in Authorization headers
    /Bearer\s+[^\s"']+/gi,
    // Long alphanumeric strings (likely API keys)
    /\b[a-zA-Z0-9]{32,}\b/g,
    // Patterns that look like secrets
    /(?:api[_-]?key|secret|password|token)[\s:="']+[^\s"']+/gi,
    // Common API key prefixes
    /\b(?:sk|pk|api|key|secret|token)[_-][a-zA-Z0-9]{16,}\b/gi,
];
/**
 * Mask sensitive data in a value.
 */
function maskSecrets(value) {
    if (typeof value === 'string') {
        let masked = value;
        for (const pattern of SECRET_PATTERNS) {
            masked = masked.replace(pattern, '[REDACTED]');
        }
        return masked;
    }
    if (Array.isArray(value)) {
        return value.map(maskSecrets);
    }
    if (value && typeof value === 'object') {
        const maskedObj = {};
        for (const [key, val] of Object.entries(value)) {
            // Always mask keys that look like secrets
            const lowerKey = key.toLowerCase();
            if (lowerKey.includes('secret') ||
                lowerKey.includes('password') ||
                lowerKey.includes('apikey') ||
                lowerKey.includes('api_key') ||
                lowerKey.includes('token')) {
                maskedObj[key] = '[REDACTED]';
            }
            else {
                maskedObj[key] = maskSecrets(val);
            }
        }
        return maskedObj;
    }
    return value;
}
/**
 * Log level priority for filtering.
 */
const LOG_LEVELS = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3,
};
/**
 * Should this level be logged?
 */
function shouldLog(level) {
    return LOG_LEVELS[level] >= LOG_LEVELS[config_js_1.config.logLevel];
}
/**
 * Generate a unique request ID.
 */
function generateRequestId() {
    return `req_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;
}
/**
 * Current request context (for tracing).
 */
let currentRequestId;
function setRequestId(id) {
    currentRequestId = id;
}
function clearRequestId() {
    currentRequestId = undefined;
}
/**
 * Core logging function.
 */
function log(level, message, data) {
    if (!shouldLog(level))
        return;
    const entry = {
        timestamp: new Date().toISOString(),
        level,
        message,
    };
    if (currentRequestId) {
        entry.request_id = currentRequestId;
    }
    // Add and mask additional data
    if (data) {
        const masked = maskSecrets(data);
        Object.assign(entry, masked);
    }
    // Output to stderr (MCP servers use stdout for protocol)
    console.error(JSON.stringify(entry));
}
/**
 * Logger instance with convenience methods.
 */
exports.logger = {
    debug: (message, data) => log('debug', message, data),
    info: (message, data) => log('info', message, data),
    warn: (message, data) => log('warn', message, data),
    error: (message, data) => log('error', message, data),
    /**
     * Log an error with stack trace.
     */
    logError: (message, error, data) => {
        log('error', message, {
            ...data,
            error_name: error.name,
            error_message: error.message,
            error_stack: error.stack,
        });
    },
};
//# sourceMappingURL=logger.js.map