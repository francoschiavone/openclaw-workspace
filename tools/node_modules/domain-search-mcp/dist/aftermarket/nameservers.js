"use strict";
/**
 * Aftermarket detection via nameserver fingerprints.
 *
 * Uses public DNS NS records to detect common parking/marketplace hosts.
 * This is ToS-safe and does not require API keys.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookupAftermarketByNameserver = lookupAftermarketByNameserver;
const promises_1 = require("node:dns/promises");
const config_js_1 = require("../config.js");
const logger_js_1 = require("../utils/logger.js");
const cache_js_1 = require("../utils/cache.js");
const NS_TIMEOUT_MS = config_js_1.config.aftermarket.nsTimeoutMs;
const nsCache = new cache_js_1.TtlCache(config_js_1.config.aftermarket.nsCacheTtl);
const NS_FINGERPRINTS = [
    {
        source: 'sedo',
        type: 'aftermarket',
        nameservers: ['ns1.sedoparking.com', 'ns2.sedoparking.com'],
        url: (domain) => `https://sedo.com/search/?keyword=${encodeURIComponent(domain)}`,
        note: 'Nameserver indicates Sedo parking. Verify listing on Sedo.',
    },
    {
        source: 'dan',
        type: 'aftermarket',
        nameservers: ['ns1.dan.com', 'ns2.dan.com'],
        url: (domain) => `https://dan.com/buy-domain/${encodeURIComponent(domain)}`,
        note: 'Nameserver indicates Dan parking. Verify listing on Dan.',
    },
    {
        source: 'afternic',
        type: 'aftermarket',
        nameservers: ['ns1.afternic.com', 'ns2.afternic.com'],
        url: (domain) => `https://www.afternic.com/forsale/${encodeURIComponent(domain)}`,
        note: 'Nameserver indicates Afternic parking. Verify listing on Afternic.',
    },
];
async function resolveNsWithTimeout(domain) {
    const timeout = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('ns_timeout')), NS_TIMEOUT_MS);
    });
    return Promise.race([(0, promises_1.resolveNs)(domain), timeout]);
}
async function lookupAftermarketByNameserver(domain) {
    if (!config_js_1.config.aftermarket.nsEnabled) {
        return null;
    }
    const key = domain.toLowerCase();
    const cached = nsCache.get(key);
    if (cached !== undefined) {
        return cached;
    }
    try {
        const nameservers = (await resolveNsWithTimeout(domain)).map((ns) => ns.toLowerCase());
        for (const fingerprint of NS_FINGERPRINTS) {
            const matches = fingerprint.nameservers.every((ns) => nameservers.includes(ns));
            if (!matches) {
                continue;
            }
            const listing = {
                type: fingerprint.type,
                price: null,
                currency: null,
                source: fingerprint.source,
                url: fingerprint.url ? fingerprint.url(domain) : undefined,
                note: fingerprint.note,
            };
            nsCache.set(key, listing);
            return listing;
        }
    }
    catch (error) {
        logger_js_1.logger.debug('Nameserver aftermarket lookup failed', {
            domain,
            error: error instanceof Error ? error.message : String(error),
        });
    }
    nsCache.set(key, null);
    return null;
}
//# sourceMappingURL=nameservers.js.map